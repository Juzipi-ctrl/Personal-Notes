# BootWiki

## c++日期&时间

c++标准库没有提供所谓的日期类型。c++继承了C语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在c++程序中引用 <ctime> 头文件。

有四个与时间相关的类型：clock_t、time_t、size_t 和 tm。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。

结构类型 tm 把日期和时间以 c 结构的形式保存， tm 结构的定义如下：

```c++
typedef struct tm{
    int tm_sec; //秒，正常范围从 0 到 59， 但允许至 61
    int tm_min; //分，范围从 0 到 59
    int tm_hour; //小时，范围从 0 到 23
    int tm_mday; //一月中的第几天，范围从 1 到 31
    int tm_mon; //月，范围从 0 到 11
    int tm_year; //自1900年起的年数
    int tm_wday; //一周中的第几天，范围从 0 到 6， 从星期日算起
    int tm_yday; //一年中的第几天，范围从 0 到 365， 从 1 月 1 日算起
    int tm_isdst; //夏令时
}
```

### 函数描述

```c++
1、time_t time(time_t *time);
//该函数返回系统的当前日历时间，自1970年1月1日以来经过的秒数。如果系统没有时间，则返回1，反之则返回0。
#include<iostream>
#include<time.h>
int main(){
    time_t secondes;
    secondes = time(NULL);
    std::cout <<"自 1970-01-01 起的小时数：" << secondes/3600 << std::endl;
    return 0;
}

2、char *ctime(const time_t *time);
//该返回一个表示当地时间的字符串指针，字符串形式 day month year hours:minutes:seconds year\n\0。
#include<iostream>
#include<time.h>
int main(){
    time_t curtime;
    time(&curtime);
    str[26];
    
    ctime_s(str, sizeof(str), &curtime);
    std::cout << "当前时间：" << str << std::endl;
    return 0;
}



3、struct tm *localtime(const time_t *time);
//该函数返回一个指向表示本地时间的 tm 的结构的指针。
#include<iostream>
#include<time.h>
int main(){
   struct tm info;
   time(&rawtime);
   struct tm info;
   char buffer[26];
    
   localtime_s(&info, &rawtime);
   asctime_s(buffer, sizeof(buffer), &info);
    
   std::cout << "当前本地时间和日期：" << buffer << std::endl;
}



4、clock_t clock(void);
//该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回1.
#include <iostream>
#include <time.h>

int main() {

  clock_t start_t, end_t;
  double total_time = 0.0;
  
  start_t = clock();

  std::cout << "程序启动：" << start_t << std::endl;
  std::cout << "开始一个大循环~~" << std::endl;

  for (int i = 0; i < 10000000; i++){ }

  end_t = clock();
  std::cout << "循环结束：" << end_t << std::endl;

  total_time = (double)(end_t - start_t) / CLOCKS_PER_SEC;
  std::cout << "CPU 占用的总时间：" << total_time << std::endl;

	return 0;
}


5、char *asctime(const struct tm *time);
//该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构体中存储的信息，返回形式为：day month date hours:minuttes year\n\0。
#include <iostream>
#include <string>
#include <time.h>

int main() {

	struct tm t;

	t.tm_sec = 10;
	t.tm_min = 10;
	t.tm_hour = 6;
	t.tm_mday = 25;
	t.tm_mon = 2;
	t.tm_year = 89;
	t.tm_wday = 6;

	char buffer[26];
	asctime_s(buffer, sizeof buffer, &t);

	std::cout << buffer << std::endl;

	return 0;
}



6、struct tm *gmtime(const time_t *time);
//该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。
#include <iostream>
#include <time.h>

#define BST (+1)
#define CCT (+8)

int main() {

  time_t rawtime;
  struct tm info;

  time(&rawtime);
  // 获取 GMT 时间
  gmtime_s(&info, &rawtime);

  std::cout << "当前的世界时钟：" << std::endl;
  std::cout << "伦敦： " << (info.tm_hour + BST) % 24 << ":" << info.tm_min
            << std::endl;
  std::cout << "中国： " << (info.tm_hour + CCT) % 24 << ":" << info.tm_min
            << std::endl;
	
	return 0;
}


7、time_t mktime(struct tm *time);
//该函数返回日历时间，相当于 time 所指向结构中存储的时间。
#include <iostream>
#include <time.h>

int main() {

  int ret;
  struct tm info;
  char buffer[80];

   info.tm_year = 2022 - 1900;
   info.tm_mon = 11 - 1;
   info.tm_mday = 14;
   info.tm_hour = 0;
   info.tm_min = 0;
   info.tm_sec = 1;
   info.tm_isdst = -1;

   ret = mktime(&info);

   if (ret == -1) {
     std::cout << "错误：不能使用 mktime 转换时间。" << std::endl;
   } else {
     strftime(buffer, sizeof buffer, "%c", &info);
     std::cout << buffer << std::endl;
   }

	return 0;
}


8、double difftime(time_t time2, time_t time1);
//该函数返回time1和time2之间相差的秒数。
#include <iostream>
#include <windows.h>
#include <time.h>

int main() {

  time_t start_t, end_t;
  double diff_t;

  std::cout << "程序开始：" << std::endl;
  time(&start_t);

  std::cout << "休息50秒..." << std::endl;
  Sleep(50000);

  time(&end_t);
  diff_t = difftime(end_t, start_t);

  std::cout << "执行时间：" << diff_t << std::endl;

	return 0;
}


9、zize_t strftime();
//该函数可用于格式化日期时间为指定的格式。
#include <iostream>
#include <windows.h>
#include <time.h>

int main() {

	time_t rawtime;
	struct tm info;
	char buffer[80];

	time(&rawtime);
	localtime_s(&info, &rawtime);

        strftime(buffer, 80, "%d - %x - %j - %H:%M:%S%p - %A", &info);
        std::cout << buffer << std::endl;

	return 0;
}

```

#### 扩展

##### 函数 - strftime()

###### 描述

```c++
c库函数 size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr) 根据 format 中定义的格式化规则，格式化结构 timeptr 表示的时间，并把它存储在 str 中。
```

###### 声明

下面是 strftime() 函数的声明：

```c++
size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)
```

###### 参数

- str - - 这是指向目标数组的指针，用来复制产生的 c 字符串。
- maxsize - - 这是被复制到 str 的醉倒字符数。
- format - - 这是 c 字符串，包含了普通字符和特殊格式说明符的任何组合。这些格式说明符由函数替换为表示 tm 中所有指定时间的相对应值。

###### 格式说明符

| 说明符 | 替换为                                                      | 实例                     |
| ------ | ----------------------------------------------------------- | ------------------------ |
| %a     | 缩写的星期几名称                                            | Sun                      |
| %A     | 完整的星期几名称                                            | Sunday                   |
| %b     | 缩写的月份名称                                              | Mar                      |
| %B     | 完整的月份名称                                              | March                    |
| %c     | 日期和时间表示法                                            | Sun Aug 19 02:56:02 2012 |
| %d     | 一月中的第几天（01 - 31）                                   | 19                       |
| %H     | 24小时格式的小时（00 - 23）                                 | 14                       |
| %I     | 12小时格式的小时（01 - 12）                                 | 05                       |
| %j     | 一年中的第几天（001 - 366）                                 | 231                      |
| %m     | 十进制数表示的月份（01 - 12）                               | 08                       |
| %M     | 分（00 - 59）                                               | 55                       |
| %p     | AM或PM名称                                                  | PM                       |
| %S     | 秒（00 - 61）                                               | 02                       |
| %U     | 一年中的第几周，以第一个星期日作为第一周的第一天（00 - 53） | 33                       |
| %w     | 十进制数表示的星期几，星期日表示为 0 （0 - 6）              | 4                        |
| %W     | 一年中的第几周，以第一个星期一作为一周的第一天（00 - 53）   | 34                       |
| %x     | 日期表示法                                                  | 08/19/12                 |
| %X     | 时间表示法                                                  | 02:50:06                 |
| %y     | 年份，最后两个数字（00 - 99）                               | 01                       |
| %Y     | 年份                                                        | 2012                     |
| %Z     | 时区的名称或缩写                                            | CDT                      |
| %%     | 一个 % 符号                                                 | %                        |

### 当前日期和时间

```c++
#include <iostream>
#include <windows.h>
#include <time.h>

int main() {

	// 基于当前系统的当前日期和时间
	time_t now;
	time(&now);

	// 把now转换为字符串形式
	char dt[80] = { '\0' };
	ctime_s(dt, sizeof dt, &now);

	std::cout << "本地日期和时间：" << dt << std::endl;

	// 把 now 转换为 tm 结构
	tm gmtm;
	gmtime_s(&gmtm, &now);
	asctime_s(dt, sizeof dt, &gmtm);

	std::cout << "UTC 日期和时间： " << dt << std::endl;


	return 0;
}

```

#### 当上名的代码被编译和执行时：

```c++
本地日期和时间：Tue Nov 15 23:30:23 2022

UTC 日期和时间： Tue Nov 15 15:30:23 2022
```

### 使用结构tm格式化时间

tm结构在c/c++中处理日期和时间相关的操作时，显得尤为重要。tm结构以c结构的形式保存日期和时间。大多数与时间相关的函数都使用了tm结构。下面的示例使用了tm结构和各种与日期和时间相关的函数。

```c++
#include <iostream>
#include <windows.h>
#include <time.h>

int main() {

  // 基于当前系统的当前日期和时间
  time_t now;
  time(&now);
  std::cout << "1900 到目前经过的秒数： " << now << std::endl;
  tm ltm;
  localtime_s(&ltm, &now);

  // 输出 tm 结构的各个组成部分
  std::cout << "年： " << 1900 + ltm.tm_year << std::endl;
  std::cout << "月： " << 1 + ltm.tm_mon << std::endl;
  std::cout << "日： " << ltm.tm_mday << std::endl;
  std::cout << "时间： " << ltm.tm_hour << ":" << ltm.tm_min << ":" << ltm.tm_sec
            << std::endl;
	return 0;
}

```

#### 当上面代码被编译和执行时：

```c++
1900 到目前经过的秒数： 1668527014
年： 2022
月： 11
日： 15
时间： 23:43:34
```

## 输入输出流

### 标准错误流（cerr）

预定义的对象 cerr 是 ostream 类的一个实例。cerr 对象所属到标准错误设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。

cerr 也是与流插入运算符 << 结合使用的：

#### 实例

```c++
#include <iostream>
int main(){
    char str[] = "Unable to read...";
    std::cerr << "Error message: " << str << std::endl;
    return 0;
}

//Error message: Unable to read...
```

### 标准日志流（clog）

预定义的对象 clog 是 ostream 类的一个实例。clog 对象附属到标准错误设备，通常也是现实屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。

clog 也是与流插入运算符 << 结合使用的：

#### 实例

```c++
#include <iostream>
int main(){
    char str[] = "Unable to read...";
    std::clog << "Error message: " << str << std::endl;
    return 0;
}

//Error message : Unable to read....
```

## c++类访问修饰符

数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 public、private、protected 来指定的。关键字 public、private、protected 称为访问修饰符。

一个类可以有多个 public、protedted 或 private 标记区域。每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。成员和类的默认访问修饰符是 private。

```c++
class Base{
    public:		//私有成员
    protected:		//受保护成员
    private:		//私有成员
};
```

### 公有（public）成员

公有成员在程序中类的外部是可访问的。可以不适用任何成员函数来设置和获取公有变量的值：

#### 实例

```c++
#include <iostream>

class Line {
public:
	double length;
	void setLength(double len);
	double getLength(void);
};

// 成员函数定义
double Line::getLength(void) { return length; }

void Line::setLength(double len) { length = len; }

int main() {

	Line line;
	// 设置长度
	line.setLength(6.0);
	std::cout << "Length of line: " << line.getLength() << std::endl;

	// 不使用成员函数设置长度
	line.length = 10.0; // ok 因为 length 是公有的
	std::cout << "Length of line:  " << line.length << std::endl;

	return 0;
}

/*
	Length of line: 6
    Length of line:  10
*/
```

### 私有（private）成员

私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。

默认情况下，类的所有成员都是私有。如果没有使用任何访问修饰符，类的成员将被假定为私有成员：

#### 实例

```c++
#include <iostream>

class Box {
private:
  double width;

public:
  double length;
  void setWidth(double width);
  double getWidth(void);
};
// 成员函数定义
double Box::getWidth(void) { return width; }

void Box::setWidth(double wid) { width = wid; }


int main() {

  Box box;
  // 不适用成员函数设置长度
  box.length = 10.0; // ok 因为 length 是公有的
  std::cout << "Length of box:  " << box.length << std::endl;

  // 不使用成员函数设置宽度
  // box.while = 10.0; // Error 因为 width 是私有de

  box.setWidth(10.0); // 使用成员函数设置宽度
  std::cout << "Width of box:  " << box.getWidth() << std::endl;

	return 0;
}


/*
Length of box:  10
Width of box:  10
*/
```

### 保护（protected）成员

保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中可访问的。

#### 实例

```c++
#include <iostream>

class Box {
protected:
  double width;
};
class SmallBOx : Box {
public:
  void setSmallWidth(double wid);
  double getSmallWidth(void);
};
// 子类成员函数
double SmallBOx::getSmallWidth(void) { return width; }

void SmallBOx::setSmallWidth(double wid) { width = wid;}

int main() {

  SmallBOx box;

  // 使用成员函数设置宽度
  box.setSmallWidth(5.0);
  std::cout << "Width of box: " << box.getSmallWidth() << std::endl;

	return 0;
}

//	Width of box: 5
```

### 继承中的特点

有 public，protected，private三种继承方式，它们相应地改变了基类成员的访问属性。

- **public 继承**：基类 public 成员，protected成员，private 成员的访问属性在派生类中分别变成：public，protected，private。
- **protected 继承**：基类public成员，protected成员，private成员的访问属性在派生类中分别变成：protected，protected，private。
- **private 继承**：基类public成员，protected成员，private成员的访问属性在派生类中分别变成：private，private，private。

无论哪种继承方式，上面两点都没有改变：

- private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；
- protected 成员可以被派生类访问；

### public继承

#### 实例

```c++
#include <assert.h>
#include <iostream>
using namespace std;
class A {
public:
	int a;
	A() {
		a1 = 1;
		a2 = 2;
		a3 = 3;
		a = 4;
	}
	void fun() {
		cout << a << endl;  // 正确
		cout << a1 << endl; // 正确
		cout << a2 << endl; // 正确
		cout << a3 << endl; // 正确
	}

public:
	int a1;

protected:
	int a2;

private:
	int a3;
};
class B : public A {
public:
	int a;
	B(int i) {
		A();
		a = i;
	}
	void fun() {
		cout << a << endl; // 正确，public成员
		cout << a1 << endl; // 正确，基类的public成员，在派生类中仍是public成员。
		cout
			<< a2
			<< endl; // 正确，基类的protected成员，在派生类中仍是protected可以被派生类访问。
		cout << a3 << endl; // 错误，基类的private成员不能被派生类访问。
	}
};
int main() {
	B b(10);
	cout << b.a << endl;
	cout << b.a1 << endl; // 正确
	cout << b.a2 << endl; // 错误，类外不能访问protected成员
	cout << b.a3 << endl; // 错误，类外不能访问private成员
	system("pause");
	return 0;
}

```

### protected 继承

#### 实例

```c++
#include<iostream>
#include<assert.h>
using namespace std;
class A {
public:
	int a;
	A() {
		a1 = 1;
		a2 = 2;
		a3 = 3;
		a = 4;
	}
	void fun() {
		cout << a << endl; //正确
		cout << a1 << endl; //正确
		cout << a2 << endl; //正确
		cout << a3 << endl; //正确
	}
public:
	int a1;
protected:
	int a2;
private:
	int a3;
};
class B : protected A {
public:
	int a;
	B(int i) {
		A();
		a = i;
	}
	void fun() {
		cout << a << endl; //正确，public成员。
		cout << a1 << endl; //正确，基类的public成员，在派生类中变成了protected，可以被派生类访问。
		cout << a2 << endl; //正确，基类的protected成员，在派生类中还是protected，可以被派生类访问。
		cout << a3 << endl; //错误，基类的private成员不能被派生类访问。
	}
};
int main() {
	B b(10);
	cout << b.a << endl; //正确。public成员
	cout << b.a1 << endl; //错误，protected成员不能在类外访问。
	cout << b.a2 << endl; //错误，protected成员不能在类外访问。
	cout << b.a3 << endl; //错误，private成员不能在类外访问。
	system("pause");
	return 0;
}


```

### private继承

#### 实例

```c++
#include<iostream>
#include<assert.h>
using namespace std;
class A {
public:
	int a;
	A() {
		a1 = 1;
		a2 = 2;
		a3 = 3;
		a = 4;
	}
	void fun() {
		cout << a << endl; //正确
		cout << a1 << endl; //正确
		cout << a2 << endl; //正确
		cout << a3 << endl; //正确
	}
public:
	int a1;
protected:
	int a2;
private:
	int a3;
};
class B : private A {
public:
	int a;
	B(int i) {
		A();
		a = i;
	}
	void fun() {
		cout << a << endl; //正确，public成员。
		cout << a1 << endl; //正确，基类public成员,在派生类中变成了private,可以被派生类访问。
		cout << a2 << endl; //正确，基类的protected成员，在派生类中变成了private,可以被派生类访问。
		cout << a3 << endl; //错误，基类的private成员不能被派生类访问。
	}
};
int main() {
	B b(10);
	cout << b.a << endl; //正确。public成员
	cout << b.a1 << endl; //错误，private成员不能在类外访问。
	cout << b.a2 << endl; //错误, private成员不能在类外访问。
	cout << b.a3 << endl; //错误，private成员不能在类外访问。
	system("pause");
	return 0;
}


```

## c++类构造函数&析构函数

### 类的构造函数

类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。

构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回void。构造函数可用于为某些成员变量设置初始值。

#### 实例

```c++
#include <iostream>

class Line {
private:
	double length;

public:
	void setLength(double len);
	double getLength(void) const;
	Line();	//这是构造函数
};

Line::Line(void) { std::cout << "Object is being created" << std::endl; }

void Line::setLength(double len) { length = len; }

double Line::getLength(void) const { return length; }

int main() {
        Line line;
        line.setLength(6.0);
        std::cout << "Length of line: " << line.getLength() << std::endl;
        return 0;
}
/*
	Object is being created
    Length of line: 6
*/
```

### 带参数的构造函数

默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值：

#### 实例

```c++
#include <iostream>

class Line {
private:
  double length;

public:
  void setLength(double len);
  double getLength(void);
  Line(double len);
};

Line::Line(double len) : length(len) {
  std::cout << "Object is being created,length = " << len << std::endl;
}

void Line::setLength(double len) { length = len; }

double Line::getLength() { return length; }

int main() {
  Line line(10.0);
  std::cout << "Length of line: " << line.getLength() << std::endl;

  line.setLength(6.0);
  std::cout << "length of line: " << line.getLength() << std::endl;

  return 0;
}
/*
Object is being created,length = 10
Length of line: 10
length of line: 6
*/
```

### 类的析构函数

类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。

析构函数的名称与类的名称是完全相同的，只是在前面加了个（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。

#### 实例

```c++
#include <iostream>

class Line {
private:
  double length;

public:
  void setLength(double len);
  double getLength() { return length; }
  Line();
  ~Line();
};

Line::Line(void) { std::cout << "Object is bength created " << std::endl; }

Line::~Line(void) { std::cout << "Object is being deleted " << std::endl; }

void Line::setLength(double len) { length = len; }

int main() {
  Line line;
  line.setLength(6.0);
  std::cout << "Length of line: " << line.getLength() << std::endl;
  return 0;
}

/*
Object is bength created
Length of line: 6
Object is being deleted
*/
```

## c++ 拷贝构造函数

**拷贝构造函数**是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：

- 通过使用另一个同类型的对象来初始化新创建的对象。
- 复制对象把它作为参数传递给函数。
- 复制对象，并从函数返回这个对象。

如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。

拷贝构造函数的最常见形式如下：

```c++
classname (const classname &obj){
    //构造函数的主体
}
```

在这里，**obj**是一个对象引用，该对象是用于初始化另一个对象的。

### 实例1

```c++
#include <iostream>

class Linedate {
private:
	int* ptr;

public:
	int getLinedate(void) { return *ptr; }
	Linedate(int lendate);
	Linedate(const Linedate& obj);
	~Linedate();
};

Linedate::Linedate(int lendate) {
	std::cout << "调用构造函数" << std::endl;
	ptr = new int;
	*ptr = lendate;
}

Linedate::Linedate(const Linedate& obj) {
	std::cout << "调用拷贝构造函数并为指针ptr分配内存" << std::endl;
	ptr = new int;
	*ptr = *obj.ptr;
}

Linedate::~Linedate(void) { delete ptr; }

void disaplay(Linedate obj) {
	std::cout << "Linedate 大小： " << obj.getLinedate() << std::endl;
}

int main() {
	Linedate line(10);
	disaplay(line);
	return 0;
}
/*
调用构造函数
调用拷贝构造函数并为指针ptr分配内存
Linedate 大小： 10
释放内存！
释放内存！
*/
```

### 实例2

```c++
#include <iostream>

class Linedate {
private:
	int* ptr;

public:
	int getLinedate(void) { return *ptr; }
	Linedate(int lendate);
	Linedate(const Linedate& obj);
	~Linedate();
};

Linedate::Linedate(int lendate) {
	std::cout << "调用构造函数" << std::endl;
	ptr = new int;
	*ptr = lendate;
}

Linedate::Linedate(const Linedate& obj) {
	std::cout << "调用拷贝构造函数并为指针ptr分配内存" << std::endl;
	ptr = new int;
	*ptr = *obj.ptr;
}

Linedate::~Linedate(void) {
    std::cout << "释放内存！" << std::endl;
    delete ptr;
}

void disaplay(Linedate obj) {
	std::cout << "Linedate 大小： " << obj.getLinedate() << std::endl;
}

int main() {
	Linedate line(10);
        Linedate line1 = line;
        disaplay(line);
        disaplay(line1);
	return 0;
}
/*
调用构造函数
调用拷贝构造函数并为指针ptr分配内存
调用拷贝构造函数并为指针ptr分配内存
Linedate 大小： 10
释放内存！
调用拷贝构造函数并为指针ptr分配内存
Linedate 大小： 10
释放内存！
释放内存！
释放内存！
*/
```

## c++友元

类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字**friend**。

```c++
class Box{
  double width;
    public:
    	double length;
    	friend void printwidth(Box box);
    	void setwidth(double wid);
};
```

声明类ClassTwo的所有成员函数作为类 ClassOne的友元，需要在类 ClassOne 的定义中：

```c++
friend class ClassTwo;
```

### 实例

```c++
#include <iostream>

class Box {
  double width;

public:
  friend void printWidth(Box box);
  void setWidth(double wid);
};

void Box::setWidth(double wid) { width = wid; }

// printWidth() 不是任何类型的成员函数
void printWidth(Box box) {
  /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */
  std::cout << "Width of box : " << box.width << std::endl;
}

int main() {
  Box box;
  box.setWidth(10.0);
  printWidth(box);
  return 0;
}

//Width of box : 10
```

## c++内联函数

c++ **内联函数**是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。

对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器重新更换一次所有的代码，否则将会继续使用旧的函数。

如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。

在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。

### 实例

```c++
#include <iostream>
using namespace std;

inline int Max(int x, int y, int z) {
  return (x > y) ? ((x > z) ? x : z) : (x > z) ? z : y;
}

int main() {
  cout << "Max (20,10,30): " << Max(20, 10,30) << endl;
  cout << "Max (0,200,100): " << Max(0, 200,100) << endl;
  cout << "Max (100,1010,999): " << Max(100, 1010,999) << endl;
    
  int (*pamx)(int, int, int) = nullptr;
  pamx = [](int x, int y, int z) -> int {
    return (x > y) ? ((x > z) ? x : z) : (x > z) ? z : y;
  };
  std::cout << pamx(30, 20, 10) << std::endl;
  return 0;
}

/*
Max (20,10,30): 30
Max (0,200,100): 200
Max (100,1010,999): 1010
*/
```

## c++this指针

在c++中，每一个对象都能通过 **this**指针类访问自己的地址。**this**指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。

友元函数没有**this**指针，因为友元不是类成员。只有成员函数才有**this**指针。

### 实例

```c++
#include <iostream>

class Box {
private:
  double length;
  double breadth;
  double height;

public:
  Box(double l = 2.0, double b = 2.0, double h = 2.0)
      : length(l), breadth(b), height(h) {
    std::cout << "Constructor called. " << std::endl;
  }
  double Volume() { return length * breadth + breadth; }

  int compare(Box box) {
    return this->Volume() > box.Volume();
  }
};


int main() {
  Box Box1(3.3, 1.2, 1.5);
  Box Box2(8.5, 6.0, 2.0);

  if (Box1.compare(Box2)) {
    std::cout << "Box2 < Box1!" << std::endl;
  } else {
    std::cout << "Box2 > Box1!" << std::endl;
  }
  return 0;
}

/*
Constructor called.
Constructor called.
Box2 > Box1!
*/
```

## c++指向类的指针

一个指向c++类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 **->**，就像访问指向结构的指针一样，与所有的指针一样，在使用之前，对指针进行初始化。

### 实例

```c++
#include <iostream>

class Box {
private:
  double length;
  double breadth;
  double height;

public:
  Box(double l = 2.0, double b = 2.0, double h = 2.0)
      : length(l), breadth(b), height(h) {
    std::cout << "Constructor called. " << std::endl;
  }
  double Volume() { return length * breadth + breadth; }

  int compare(Box box) {
    return this->Volume() > box.Volume();
  }
};

int main() {
  Box Box1(3.3, 1.2, 1.5);
  Box Box2(8.5, 6.0, 2.0);

  Box *ptrBox ;
  
  // 保存第一个对象的地址
  ptrBox = &Box1;

  // 现在尝试使用成员访问运算符来访问成员
  std::cout << "Volume of Box1: " << ptrBox->Volume() << std::endl;

  // 保存第二个对象的地址
  ptrBox = &Box2;

  // 现在尝试使用成员访问运算符来访问成员
  std::cout << "Volume of Box2: " << ptrBox->Volume() << std::endl;

  
        return 0;
}

/*
Constructor called.
Constructor called.
Volume of Box1: 5.16
Volume of Box2: 57
*/
```

## c++类的静态成员

可以使用 **static**关键字来把类成员定义为静态的。当我们声明的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有给一个副本。

静态成员在类的所有对象中是共享的。如果不存在其他任何语句，在创建第一个对象时，所有的静态数据都会初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符**::**来声明静态变量从而对它进行初始化。

### 实例

```c++
#include <iostream>

class Box{
private:
  double length;
  double width;
  double height;

public:
  static int objectcom;
  Box(double l = 2.0, double b = 2.0, double h = 2.0)
      : length(l), width(b), height(h) {
    std::cout << "Constructot called. " << std::endl;
    //每次创建对象 加一
    objectcom++;
  }
  double Volume() {
    return length * width * height;
  }
};
//初始化类 Box 的静态成员
int Box::objectcom = 0;
int main() {

  Box Box1(3.3, 1.2, 1.5); // 声明 box1
  Box Box2(8.5, 6.0, 2.0); // 声明 box2

  // 输出对象的总数
  std::cout << "Total objects: " << Box::objectcom<< std::endl;

  return 0;
}
/*
Constructot called. 
Constructot called.
Total objects: 2
*/
```

### 静态成员函数

如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，**静态函数**只要使用类名加范围解析运算符**::** 就可以访问。

静态成员函数只能访问静态成员数据，其他静态成员函数和类外部的其他函数。

静态成员函数有一个类范围，它们不能访问类的 this 指针。可以使用静态成员函数来判断类的某些对象是否已被创建。

#### 静态成员函数与普通成员函数的区别

- 静态成员函数没哟 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。
- 普通成员函数有this指针，可以访问类中任意成员；而金泰成员函数没有 this指针。

### 实例

```c++
#include <iostream>

class Box{
private:
  double length;
  double width;
  double height;

public:
  static int objectcom;
  Box(double l = 2.0, double b = 2.0, double h = 2.0)
      : length(l), width(b), height(h) {
    std::cout << "Constructot called. " << std::endl;
    //每次创建对象 加一
    objectcom++;
  }
  double Volume() { return length * width * height; }

  static int getCount() { return objectcom; }
};
//初始化类 Box 的静态成员
int Box::objectcom = 0;
int main() {

  // 在创建对象之前输出对象的总数
  std::cout << "Inital Stage Count: " << Box::getCount() << std::endl;
  
  Box Box1(3.3, 1.2, 1.5); // 声明 box1
  Box Box2(8.5, 6.0, 2.0); // 声明 box2

  // 输出对象的总数
  std::cout << "Total objects: " << Box::objectcom<< std::endl;

  return 0;
}

/*
Inital Stage Count: 0
Constructot called. 
Constructot called. 
Total objects: 2
*/
```

## c++继承

面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。

当创建一个类时，不需要重新编写新的数据成员和成员函数，只需要指定新建的类继承了一个已有的类的成员即可。这个已有的类称为**基类**，新建的类称为**派生类**。

### 基类&派生类

一个类可以派生自多个类，这意味着，它可以从基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：

```c++
class derived-class: access-specifier base-class
```

其中，访问修饰符 access-specifier 是 **public，protected**或**private**其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。

###实例

```c++
#include <iostream>
//基类
class Shape {
protected:
  int width, height;

public:
  void setWidth(int w) { width = w; }

  void setHeight(int n) { height = n; }
};
// 派生类
class Rectangle : public Shape {
public:
  int getArea() {
    return (width * height);
  }
};

int main() {
  Rectangle Rect;
  Rect.setWidth(5);
  Rect.setHeight(7);
  // 输出对象的面积
  std::cout << "Total area: " << Rect.getArea() << std::endl;
  return 0;
}

/*
Total area: 35
*/
```

### 访问控制和继承

派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类声明为**private**。

一个派生类继承了所有的基类方法，但下列情况除外：

- 基类的构造函数，析构函数和拷贝构造函数。
- 基类的重载运算符。
- 基类的友元函数。

### 继承类型

当一个类派生自基类，该基类可以被继承为**public，protected**或**private**几种类型。

- **公有继承（public）**：当一个派生类生自**公有**基类时，基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员。
- **保护继承（protected）**：当一个类派生自**保护**基类时，基类的**公有**和**保护**成员将成为派生类的**保护**成员。
- **私有继承（private）**：当一个类派生自**私有**基类时，基类的**公有**和**保护**成员将成为派生类的**私有**成员。

### 多继承

多继承即一个子类可以有多个父类，它继承了多个父类的特性。

C++类可以从多个类继承成员，语法如下：

```c++
class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…
{
<派生类类体>
};

```

其中，访问修饰符继承方式是 **public，protected**或**private**其中的一个，用来修饰每个基类，各个基类之间用逗号分隔。

### 实例

```c++
#include <iostream>
//基类
class Shape {
protected:
  int width, height;

public:
  void setWidth(int w) { width = w; }

  void setHeight(int n) { height = n; }
};
class PaintCost {
public:
  int getCost(int area) {
    return area * 70;
  }
};
// 派生类
class Rectangle : public Shape , public PaintCost {
public:
  int getArea() {
    return (width * height);
  }
};

int main() {
  Rectangle Rect;
  int area;
  Rect.setWidth(5);
  Rect.setHeight(7);
  area=Rect.getArea();
  // 输出对象的面积
  std::cout << "Total area: " << Rect.getArea() << std::endl;
  // 输出总花费
  std::cout << "Total paint cost $: " << Rect.getCost(area) << std::endl;
  return 0;
}

/*
Total area: 35
Total paint cost $: 2450
*/
```

## c++重载运算符和重载函数

c++允许在同一个作用域中的某个**函数**和**运算符**指定多个定义，分别称为**函数重载**和**运算符重载**。

重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。

调用一个**重载函数**或**重载运算符**时，编译器通过所使用的参数类型定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为**重载决策**。

### c++中的函数重载

在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或顺序）必须不同。不仅通过返回类型的不同来重载函数。

### c++中的运算符重载

可以重新定义或重载大部分c++内置的运算符。这样，就能使用自定义类型的运算符。

重载运算符是带有特殊名称的函数，函数名是由关键字 **operator**和其后要重载的运算符符号的构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。

```c++
Box operator+(const Box&);
```

声明加法运算符用于把两个Box对象相加，返回最终的Box对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：

```c++
Box operator+(const Box&, const Box&)
```

####实例

```c++
#include <iostream>

class Box {
private:
  double length;
  double width;
  double height;

public:
  double getVolume() const { return length * width * height; };

  void setLength(double len) { length = len; }

  void setBreadth(double wid) { width = wid; }

  void setHeight(double hei) { height = hei; }
  // 重载 + 运算符，用于把两个 Box 对象相加
  Box operator+(const Box &boss) {
    Box box;
    box.length = this->length + boss.length;
    box.width = this->width + boss.width;
    box.height = this->height + boss.height;
    return box;
  }
};

int main() {

  Box Box1, Box2, Box3;
  double volume = 0.0;
  // Box1 详述
  Box1.setLength(6.0);
  Box1.setBreadth(7.0);
  Box1.setHeight(5.0);
  // Box2 详述
  Box2.setLength(12.0);
  Box2.setBreadth(13.0);
  Box2.setHeight(10.0);

  // Box1 的体积
  volume = Box1.getVolume();
  std::cout << "Volume of Box1 : " << volume << std::endl;
  // Box2 的体积
  volume = Box2.getVolume();
  std::cout << "Volume of Box2 : " << volume << std::endl;
  // 把两个对象相加，得到 Box3
  Box3 = Box1 + Box2;
  // Box3 的体积
  volume = Box3.getVolume();
  std::cout << "Volume of Box3 : " << volume << std::endl;

        return 0;
}

/*
Volume of Box1 : 210
Volume of Box2 : 1560
Volume of Box3 : 5400
*/
```

### c++一元运算符重载

一元运算符只对一个操作数进行操作，例如：

- 递增运算符（++）和递减运算符（- -）
- 一元减运算符，即负号（-）
- 逻辑非运算符（！）

一元运算符通常出现在它们所操作的对象的左边，比如 !obj、-obj 和 ++obj,但是有时它们也可以作为后缀，比如 obj++ 或 obl- -。

#### 实例

```c++
#include <iostream>
class Distance {
private:
  int feet, inches;

public:
  Distance() : feet(0), inches(0) {}

  Distance(int fee, int inche) : feet(fee), inches(inche) {}

  void displayDistance() {
    std::cout << "F: " << feet << "  I: " << inches << std::endl;
  }

  Distance operator-() {
    feet = -feet;
    inches = -inches;
    return Distance(feet, inches);
  }
};

int main() {
  Distance D1(11, 10), D2(-5, 11);
  -D1;                  // 取相反数
  D1.displayDistance(); // 距离 D1
  -D2;                  // 取相反数
  D2.displayDistance(); // 距离 D2
  return 0;
}

/*
F: -11  I: -10
F: 5    I: -11
*/
```

### c++二元运算符重载

二元运算符需要两个参数，平时使用的加运算符（+）、减运算符（-）、乘运算符（*）和除运算符（/）都属于二元运算符

#### 实例

```c++
#include <iostream>

class Box {
private:
  double length, width, hetht;

public:
  double getVolume(void) const { return length * width * hetht; }

  void setLength(double len) { length = len; }

  void setWidth(double wid) { width = wid; }

  void setHeight(double hei) { hetht = hei; }

  // 重载 + 运算符，用于把两个 Box 对象相加

  Box operator+(const Box &boos) {
    Box box;
    box.length = this->length + boos.length;
    box.width = this->width + boos.width;
    box.hetht = this->hetht + boos.hetht;
    return box;
  }
};

int main() {
  Box Box1;            // 声明 Box1，类型为 Box
  Box Box2;            // 声明 Box2，类型为 Box
  Box Box3;            // 声明 Box3，类型为 Box
  double volume = 0.0; // 把体积存储在该变量中

  // Box1 详述
  Box1.setLength(6.0);
  Box1.setWidth(7.0);
  Box1.setHeight(5.0);

  // Box2 详述
  Box2.setLength(12.0);
  Box2.setWidth(13.0);
  Box2.setHeight(10.0);

  // Box1 的体积
  volume = Box1.getVolume();
  std::cout << "Volume of Box1 : " << volume << std::endl;

  // Box2 的体积
  volume = Box2.getVolume();
  std::cout << "Volume of Box2 : " << volume << std::endl;

  // 把两个对象相加，得到 Box3
  Box3 = Box1 + Box2;

  // Box3 的体积
  volume = Box3.getVolume();
  std::cout << "Volume of Box3 : " << volume << std::endl;

  return 0;
}

/*
Volume of Box1 : 210
Volume of Box2 : 1560
Volume of Box3 : 5400
*/
```

### c++ 关系运算符

c++语言支持各种关系运算符（<.	>,	<=,	>=,	==）等等，它们可用于比较c++内置的数据类型。

可以重载任何一个关系运算符，重载后的关系运算符可用于比较类的对象。

#### 实例

```c++
#include <iostream>

class Distance {
private:
  int feet, inches;

public:
  Distance() : feet(0), inches(0) {}

  Distance(int fe, int in) : feet(fe), inches(in) {}

  void displayDistance() {
    std::cout << "F: " << feet << "   I: " << inches << std::endl;
  }

  Distance operator-() {
    feet = -feet;
    inches = -inches;
    return Distance(feet, inches);
  }

  bool operator<(const Distance &other) const {
    if (feet < other.feet) {
      return true;
    }
    if (feet == other.feet && inches < other.inches) {
      return true;
    }
    return false;
  }
};

int main() {
  Distance D1(11, 10), D2(5, 11);

  if (D1 < D2) {
    std::cout << "D1 is less than D2 " << std::endl;
  } else {
    std::cout << "D2 is less than D1 " << std::endl;
  }
  return 0;
}

/*
D2 is less than D1
*/
```

### c++输入或输出运算符重载

c++能够使用流量提取运算符 **>>**和流插入运算符**<<**来输入和输出内置的数据类型。可以重载流提取运算符和插入流运算符来操作对象用户自定义的数据类型。

#### 实例

```c++
#include <iostream>

class Distance {
private:
  int feet, inches;

public:
  Distance() : feet(0), inches(0) {}

  Distance(int fe, int in) : feet(fe), inches(in) {}

  void displayDistance() {
    std::cout << "F: " << feet << "   I: " << inches << std::endl;
  }

  Distance operator-() {
    feet = -feet;
    inches = -inches;
    return Distance(feet, inches);
  }

  bool operator<(const Distance &other) const {
    if (feet < other.feet) {
      return true;
    }
    if (feet == other.feet && inches < other.inches) {
      return true;
    }
    return false;
  }

  friend std::ostream &operator<<(std::ostream &output, const Distance &Deket) {
    output << "F: " << Deket.feet << "  I: " << Deket.inches;
    return output;
  }
  friend std::istream &operator>>(std::istream &input, Distance &Depet) {
    input >> Depet.feet >> Depet.inches;
    return input;
  }

};

int main() {
  Distance D1(11, 10), D2(5, 11), D3;

  std::cout << "Enter the value of object : " << std::endl;
  std::cin >> D3;
  std::cout << "First Distance : " << D1 << std::endl;
  std::cout << "Second Distance :" << D2 << std::endl;
  std::cout << "Third Distance :" << D3 << std::endl;

  return 0;
}

/*
./htests.exe                                                             [19:40:37]
Enter the value of object :
20
80
First Distance : F: 11  I: 10
Second Distance :F: 5   I: 11
Third Distance : F: 20   I: 80
*/
```

### c++ （++）和（- -）运算符重载

递增运算符（ ++ ）和递减运算符（ -- ）是 C++ 语言中两个重要的一元运算符。

#### 实例

```c++
#include <iostream>
using namespace std;
class Time {
private:
  int hours;   // 0 到 23
  int minutes; // 0 到 59
public:
  // 所需的构造函数
  Time() {
    hours = 0;
    minutes = 0;
  }
  Time(int h, int m) {
    hours = h;
    minutes = m;
  }
  // 显示时间的方法
  void displayTime() { cout << "H: " << hours << " M:" << minutes << endl; }
  // 重载前缀递增运算符（ ++ ）
  Time operator++() {
    ++minutes; // 对象加 1
    if (minutes >= 60) {
      ++hours;
      minutes -= 60;
    }
    return Time(hours, minutes);
  }
  // 重载后缀递增运算符（ ++ ）
  Time operator++(int) {
    // 保存原始值
    Time T(hours, minutes);
    // 对象加 1
    ++minutes;
    if (minutes >= 60) {
      ++hours;
      minutes -= 60;
    }
    // 返回旧的原始值
    return T;
  }
};
int main() {
  Time T1(11, 59), T2(10, 40);
  ++T1;             // T1 加 1
  T1.displayTime(); // 显示 T1
  ++T1;             // T1 再加 1
  T1.displayTime(); // 显示 T1
  T2++;             // T2 加 1
  T2.displayTime(); // 显示 T2
  T2++;             // T2 再加 1
  T2.displayTime(); // 显示 T2
  return 0;
}

/*
H: 12 M:0
H: 12 M:1
H: 10 M:41
H: 10 M:42
*/
```

### c++赋值运算符

可以重载赋值运算符（ = ），用于创建一个对象，比如拷贝构造函数。

#### 实例

```c++
#include <iostream>

class Distance {
private:
  int feet, inches;

public:
  Distance() : feet(0), inches(0) {}

  Distance(int fe, int in) : feet(fe), inches(in) {}

  void displayDistance() {
    std::cout << "F: " << feet << "   I: " << inches << std::endl;
  }

  void operator=(const Distance &other) {
    feet=other.feet; inches=other.inches;
  }

};

int main() {
  Distance D1(11, 10), D2(5, 11);

  std::cout << "First Distance : ";
  D1.displayDistance();
  std::cout << "Second Distance :";
  D2.displayDistance();

  // 使用赋值运算符
  D1 = D2;
  std::cout << "First Distance :";
  D1.displayDistance();

  return 0;
}

/*
First Distance : F: 11   I: 10
Second Distance :F: 5    I: 11
First Distance : F: 5    I: 11
*/
```

### c++函数调用运算符（）重载

函数调用运算符（）可以被重载用于类的对象。当重载（）时，不是创造了一种新的调用函数方式，相反的，这是创建一个可以传递任意数目的运算符函数。

#### 实例

```c++ 
#include <iostream>

class Distance {
private:
  int feet, inches;

public:
  Distance() : feet(0), inches(0) {}

  Distance(int fe, int in) : feet(fe), inches(in) {}

  void displayDistance() {
    std::cout << "F: " << feet << "   I: " << inches << std::endl;
  }

  Distance operator()(int fe, int in, int jp) {
    Distance deket;
    deket.feet = fe + in + 10;
    deket.inches = in + jp + 100;
    return deket;
  }

};

int main() {
  Distance D1(11, 10), D2;
  std::cout << "First Distance : ";
  D1.displayDistance();

  D2 = D1(10, 10, 10); // invoke operator()
  std::cout << "Second Distance :";
  D2.displayDistance();

  return 0;
}

/*
First Distance : F: 11   I: 10
Second Distance :F: 30   I: 120
*/
```

### c++小标运算符[ ] 重载

下标操作符 [ ] 通常用于访问数组元素。重载该运算符用于增强操作c++数组的功能。

#### 实例

```c++
#include <iostream>
using namespace std;
const int SIZE = 10;

class safearay {
private:
  int arr[SIZE];

public:
  safearay() {
    register int i;
    for (i = 0; i < SIZE; i++) {
      arr[i] = i;
    }
  }
  int &operator[](int i) {
    if (i > SIZE) {
      cout << "索引超过最大值" << endl;
      // 返回第一个元素
      return arr[0];
    }
    return arr[i];
  }
};
int main() {
  safearay A;

  cout << "A[2] 的值为 : " << A[2] << endl;
  cout << "A[5] 的值为 : " << A[5] << endl;
  cout << "A[12] 的值为 : " << A[12] << endl;

  return 0;
}

/*
A[2] 的值为 : 2
A[5] 的值为 : 5
A[12] 的值为 : 索引超过最大值
0
*/
```

## c++多态

**多态**按字面的意思就是多种形态。当类之间村子层次结构，并且类之间是通过继承关联时，就会用到多态。

c++多态意味着调用成员函数时，会根据调用的对象类型来执行不同的函数。

### 实例1

```c++
#include <iostream>

class Shape {
protected:
  int width, heiht;

public:
  Shape(int apec = 0, int bois = 0) : width(apec), heiht(bois) {}

   int area() {
    std::cout << "Parent class area: " << width << heiht << std::endl;
    return 0;
  }
};

class Rectangle : public Shape {
public:
  Rectangle(int apec = 0, int bois = 0) : Shape(apec, bois) {}

  int area() {
    std::cout << "Rectangle class area: " << width << heiht << std::endl;
    return (width * heiht);
  }
};

class Triangle : public Shape {
public:
  Triangle(int apac = 0, int bois = 0) : Shape(apac, bois) {}

  int area() {
    std::cout << "Triangle class area: " << width << heiht << std::endl;
    return (width * heiht / 2);
  }
};

int main() {
  Shape *shape;
  Rectangle rec(10, 7);
  Triangle tri(10, 5);
  // 存储矩形的地址
  shape = &rec;
  // 调用矩形的求面积函数 area
  shape->area();
  // 存储三角形的地址
  shape = &tri;
  // 调用三角形的求面积函数 area
  shape->area();
  return 0;
}

/*
Parent class area: 107
Parent class area: 105
*/
```

导致错误输出的原因是，调用函数 **area()**被编译器设置为基类中的版本，这就是所谓的**静态多态**或**静态链接**-函数调用在程序执行前就准备好了。有时候这也被称为**早绑定**，因为**area()**函数在程序编译期间就已经设置好了。

在Shape类中，area()的声明前放置关键字**virtual**，如下：

###实例2

```c++
class Shape {
protected:
  int width, heiht;

public:
  Shape(int apec = 0, int bois = 0) : width(apec), heiht(bois) {}

  virtual int area() {
    std::cout << "Parent class area: " << width << heiht << std::endl;
    return 0;
  }
};

/*
Rectangle class area: 107
Triangle class area: 105
*/
```

此时，编译器看的是**指针**的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 （*shape）中，所以会调用各自的 area() 函数。正如看到的，每个子类都有一个函数 area() 的独立实现。这就是***多态的**的一般使用方式。有了多态，可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。

### 虚函数

**虚函数**是在基类中使用关键字**virtual**声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。

想要在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。

**纯虚函数**在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。

### 实例3

```c++
class Shape {
protected:
  int width, heiht;

public:
  Shape(int apec = 0, int bois = 0) : width(apec), heiht(bois) {}

  virtual int area() =0;
};

/*
Rectangle class area: 107
Triangle class area: 105
*/
```

= 0 告诉编译器，函数没有主体，上面的虚函数是**纯虚函数**。

## c++数据抽象

数据抽象是指，指向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不是呈现细节。

数据抽象是一种依赖于接口和实现分离的编程（设计）技术。

c++编程而言，c++类为**数据抽象**提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就说，外界实际上并不清楚类的内部实现。

#### 访问标签强制抽象

在C++中，使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：

- 使用公共标签定义的成员可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。
- 使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。

访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。

#### 数据抽象的好处

数据抽象有两个重要的优势：

- 类的内部受到保护，不会因无意的用户级错误导致对象状态受损。
- 类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对哪些要求不改变用户级代码的错误报告。

如果只在类的私有部分定义的数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致那些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响。

#### 数据抽象的实例

```c++
#include <iostream>

class Adder {
private:
  // 对外隐藏的数据
  int total;

public:
  //构造函数
  Adder(int teal = 0) : total(teal) {}

  // 对外的接口
  void addNum(int number) { total += number; }

  // 对外的接口
  int getTotal(){return total;}
};

int main() {
  Adder adder;
  adder.addNum(10);
  adder.addNum(20);
  adder.addNum(30);

  std::cout << "Total: " << adder.getTotal() << std::endl;

  return 0;
}

/*
Total: 60
*/
```

####设计策略

抽象把代码分离为借口和事项。所以在设计组件时，必须保持接口独立于事项，这样，如果改变底层实现，接口也将保持不变。

## c++接口（抽象类）

c++接口是使用**抽象类**来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。

如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “=0”类指定的，例如：

```c++
class Box{
    private:
    	double length, width, heiht;
    public:
    	virtual double getVolume() = 0;
};
```

设计**抽象类**(通常称为 ABC)的目的，是为了给其他类提供一个可以继承的适当的基类。抽象不能被调用与实现化对象，它只能作为**接口**使用。如果试图实例化一个抽象类的对象，会导致编译错误。

因此，如果一个ABC的子类需要被实例化，则必须实现每个虚函数，这意味着c++支持使用ABC声明接口。如果没有派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。

可用于实例化对象的类被称为**具体类**。

### 示例

```c++
#include <iostream>

class Shape {
protected:
  int width, height;

public:
  virtual int getArea() = 0;

  void setWidth(int wid) { width = wid; }

  void setHeight(int hei) { height = hei; }
};

class Rectangle : public Shape {
public:
  int getArea() { return (width * height); }
};

class Triangle : public Shape {
public:
  int getArea() { return (width * height) / 2; }
};

int main() {
  Rectangle Rect;
  Triangle Tri;
  Rect.setWidth(5);
  Rect.setHeight(7);
  // 输出对象的面积
  std::cout << "Total Rectangle area: " << Rect.getArea() << std::endl;
  Tri.setWidth(5);
  Tri.setHeight(7);
  // 输出对象的面积
  std::cout << "Total Triangle area: " << Tri.getArea() << std::endl;

  return 0;
}

/*
Total Rectangle area: 35
Total Triangle area: 17
*/
```

### 设计策略

面向对象的系统可能会使用一个抽象基类为所有外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过抽象基类，就把所有类似的操作都继承下来。

外部应用程序提供的功能（即公有函数）在抽象基类是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类总被实现。

这个架构使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此。

## c++文件和流

已经使用了**iostream**标准库，它提供了**cin**和**cout**方法用于标准输入读取流和向标准输出写入流。

文件的读取和问价写入流。需要用到c++中另一个标准库**fstream**，它定义了三个新的数据类型。

| 数据类型 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| ofstream | 该数据类sing表示输入文件流，用于创建文件并向文件写入信息     |
| ifstream | 该数据类型表示输入文件流，用于从文件读取信息                 |
| fstream  | 给数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 |

要在c++中进行文件处理，必须在c++源代码文件中包含头文件 <iostream> 和 <fstream>。

### 打开文件

从文件读取信息或者向文件写入信息之前，必须先打开文件。**ofstream**和**fstream**对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用**ifstream**对象。

例如：下面 open() 函数的标准语法，open() 函数是 fstream, ifstream 和 ofstream 对象的一个成员。

```c++
void open(const char *filename, ios::openmode mode);
```

在这里，**open()**成员函数的第一参数指定要打开的文件的名称和位置，第二参数定义文件被打开的模式。

| 模式标志        | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| std::ios::app   | 追加模式。所有写入都追加到文件末尾                           |
| std::ios::ate   | 文件打开后定位到文件末尾                                     |
| std::ios::in    | 打开文件用于读取                                             |
| std::ios::out   | 打开文件用于写入                                             |
| std::ios::trunc | 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 |

把以上两种或两种以上的模式结合使用。例如，想要以写入模式打开，并希望截断文件，以防文件已存在，可以使用下面的语法：

```c++
std::ofstream outfile;
outfile.open("file.dat", std::ios::out | std::ios::trunc);
```

类似的，要打开一个文件用于读写，可以使用以下方法：

```c++
std::fstream afile;
afile.open("fille.dat", std::ios::out | std::ios::in);
```

### 关闭文件

当c++程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。

下面是 close() 函数的标准语法， close() 函数是 fstream, ifstream 和 ofstream 对象的一个成员。

```c++
void close();
```

### 写入文件

在c++编程中，我们使用流插入运算符（<<）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里使用的是 **ofstream**或**fstream**对象，而不是 **cout**对象。

### 读取文件

在 c++ 编程中，我们使用流提取运算符（>>）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里使用的是**ifstream**或**fstream**对象，而不是**cin**对象。

### 文件位置指针

**istream**和**ostream**都提供了用于重新定位位置指针的成员函数。这些成员函数包括关于 istream的**seekg**（“seek get”）和关于 ostream的 **seekp**(“seek put”)。

seekg和seekp的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是**std::ios::beg**（默认的，从流的开头开始定位），也可以是**std::ios::cur**（从流的当前位置开始定位），也可以是**std::ios::end**（从流的末尾开始定位）。

文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。

关于定位“get”文件位置指针的实例：

### 实例

```c++
//定位到 fileObject 的第 n 个字节（假设是 std::ios::beg）
fileObject.seekg(n);
//把文件的读指针从 fileObject 当前位置向后移 n 个字节
fileObject.seekg(n, std::ios::cur);
//把文件的读指针从 fileObject 末尾往回移 n 个字节
fileobject.seekg(n, std::ios::end);
//定位到 fileObject 的末尾
fileObject.seekg(0, std::ios::end);
```

## c++异常处理

异常是程序在执行期间产生的问题。c++异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。

异常提供了一种转移程序控制权的方式。c++异常处理涉及到三个关键字：**try、catch、throw**。

- **throw：**当问题出现时，程序会抛出一个异常。这是通过使用**throw**关键字来完成的。
- **catch：**想要处理问题的地方，通过异常处理程序捕获异常。**catch**关键字用于捕获异常。
- **try：**代码表示将被激活的特定异常。它后面通常跟着一个或多个 catch 块。

如果一个块抛出一个异常，捕获异常的方式会使用**try**和**catch**关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try 或 catch 语句的语法如下所示：

###实例

```c++
try{
    //保护代码
}catch(ExceptionName e2){
    //catch 块
}catch(ExceptionName e3){
    //catch 块
}catch(ExceptionName eN){
    //catch 块
}
```

如果**try**块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个**catch**语句，用于捕获不同类型的异常。

### 抛出异常

可以使用**throw**语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。

例如：抛出除以零的异常实例：

```c++
double divsion(int a, int b){
    if(b == 0){
        throw "Division by zero condition!";
    }
    return (a/b);
}
```

### 捕获异常

**catch**块跟在**try**块后面，用于捕获异常。可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。

```c++
try{
    //保护代码
}catch(ExceptionName eN){
    //处理 ExceptionName 异常的代码
}
```

上面的代码会捕捉一个类型为 **ExceptionName**的异常。如果想要 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常括号内使用省略号 …，如下所示：

```c++
try{
    //保护代码
}catch(...){
    //能够处理任何异常的代码
}
```

### 实例

```c++
#include <iostream>

double divsion(int a, int b) {
  if (b == 0) {
    throw "Division by zero condition!";
  }
  return (a/b);
}
int main() {
  int x = 50, y = 0;
  double z = 0;

  try {
    z = divsion(x, y);
    std::cout << z << std::endl;
  } catch (const char *msg) {
    std::cerr << msg << std::endl;
  }
  return 0;
}

/*
Division by zero condition!
*/
```

抛出了一个类型为 **const char* ** 的异常，当捕获异常时，必须在 catch 块中使用 const char *。

### 标准的异常

c++提供了一系列标准的异常，定义在**exception**中，可以在程序中使用这些标准的异常，。它们是以父类层次结构组织起来的，如：

![异常标准](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221201192755601.png)

| 异常                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| std::exception         | 该异常是所有标准c++异常的父类                                |
| std::bad_alloc         | 该异常可以通过 **new**抛出                                   |
| std::bas_cast          | 该异常可以通过**dynamic_cast**抛出                           |
| std::bad_exception     | 这在处理c++程序中无法预期的异常时非常有用                    |
| std::bad_typeid        | 该异常可以通过**typeid**抛出                                 |
| **std::logic_error**   | 理论上可以通过读取代码类检测的异常                           |
| std::domain_error      | 当使用了一个无效的数学检测是，会抛出该异常                   |
| std::invalid_argument  | 当使用了无效的参数时，会抛出该异常                           |
| std::length_error      | 当创建了太长 std::string 时，会抛出该异常                    |
| std::out_of_range      | 该异常可以通过方法抛出，例如 std::vector 和 std::bitset<>::operator[]() |
| **std::runtime_error** | 理论上不可以通过读取代码来检测到的异常                       |
| std::overflow_error    | 当发生数学上溢时，会抛出该异常                               |
| std::reange_error      | 当尝试存储超出范围的值时，会抛出该异常                       |
| std::underflow_error   | 当发生数学下溢，会抛出该异常                                 |

### 定义新的异常

可以通过继承和重载**exception**类来定义新的异常。例如：

### 实例

```c++
#include <iostream>
#include <exception>

struct MyException : public std::exception {
  const char *what() const throw() { return "c++ exception"; }
};

int main() {

  try {
    throw MyException();
  } catch (MyException &e) {
    std::cout << "MyException caught" << std::endl;
    std::cout << e.what() << std::endl;
  } catch (std::exception &e) {
    //其他错我
  }
  return 0;
}

/*
MyException caught
c++ exception
*/
```

**what()**是异常类提供的一个共有方法，它已被所有子类异常重载。

## c++动态内存

c++程序中的内存分为两个部分：

- **栈**：在函数内部声明的所有变量都将占用栈内存。
- **堆**：这是程序中未使用的内存，在程序运行时可用于动态分配内存。

很多时候，无法预知需要多少内存类存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。

在c++中， 可以使用特殊的运算符为给定类型的变量在运行时分分配堆内的内存，这会返回所分配的空间地址。这种运算符即**new**运算符。

不需要动态分配内存，可以使用**delete**运算符，删除之前由 new运算符分配的内存。

### new 和 delete 运算符

使用 new 运算符来为任意的数据类型动态分配内存的通用语法：

```c++
new data-type;
```

在这里，**data-type**可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。例如，可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。语句使用 **new**运算符来完成这点：

```c++
double *pvalue = NULL;  //初始化为 null 的指针
pvalue = new double;   //为变量请求内存
```

如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：

```c++
double *pvalue = NULL;
if(!(pvalue = new double)){
    std::cout << "Error out of memory." << std::endl;
    exit(1);
}
```

**malloc()**函数在 C语言中就出现了， 在 c++ 中任然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc()函数相比，其主要的优点是， new 不只是分配了内存，它还创建了对象。

任何时候，觉得某个已经动态内存分配内存的变量不再需要使用时，可以使用 delete 操作符释放它所占的内存，例如：

```c++
delete pvalue;		//释放 pvalue 所指向的内存
```

### 实例

```c++
#include <iostream>

int main() {
  double *pvalue = NULL;  //初始化为 null 的指针
  pvalue = new double;    // 为变脸请求内存
  *pvalue = 29494.99;     // 在分配的地址存储值
  std::cout << "value of pvalue: " << *pvalue << std::endl;
  delete pvalue;
  return 0;
 }

/*
value of pvalue: 29494.99
*/
```

### 数组的动态内存分配

为一个字符数组（一个有20个字符的字符串）分配内存，可以使用：

```c++
char *pvalue  = NULL;
pvalue = new char[20];
```

删除语法：

```c++
delete [] pvalue;
```

new 操作符的通用语法，多维数组分配内存：

#### 一维数组

```c++
//动态分配数组长度为 m
int *array = new int[m];
//释放内存
delete [] array;
```

#### 二维数组

```c++
int **array;

//动态分配空间
array = new int *[m];
for (int i = 0; i < m; i++){
    array[i] = new int[n];
}
//释放
for (int i = 0; i < m; i++){
    delete [] array[i];
}
delete [] array;
```

### 对象的动态内存分配

对象与简单的数据类型没有什么不同。

### 实例

```c++
#include <iostream>

class Box {
public:
  Box() { std::cout << "调用构造函数！" << std::endl; }

  ~Box() { std::cout << "调用析构函数！" << std::endl; }
};

int main() {
  Box *myBoxArray = new Box[4];
  delete [] myBoxArray;
  return 0;
}

/*
调用构造函数！
调用构造函数！
调用构造函数！
调用构造函数！
调用析构函数！
调用析构函数！
调用析构函数！
调用析构函数！
*/
```

## c++命名空间

#### 定义命名空间

命名空间的定义使用关键字**namespace**，后跟命名空间的名称，如下所示：

```c++
namespace namespace_name{
    //代码声明
}
```

为调用带有命名空间的函数或变量，需要在前面加上命名空间的名称：

```c++
name::code;		//code 可以是变量或函数
```

### 实例

```c++
#include <iostream>

// 第一个命名空间
namespace first_space {
void func() {
  std::cout << "Lnside first_space" << std::endl;
}
}
// 第二个命名空间
namespace second_space {
void func() {
  std::cout << "Lnside second_space" << std::endl;
}
} // namespace second_space

int main() {
  first_space::func();
  second_space::func();
  return 0;
}

/*
Lnside first_space
Lnside second_space
*/
```

### using指令

可以使用**using namespace**指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。

```c++
using namespace type;
```

## c++模板

模板是泛型编程的基础，泛型编程即以一种独立与任何特定类型的方式编写代码。

模板是创建泛型或函数的蓝图或公式。库容器，比如迭代器和算符，都是泛型编程的例子，它们都使用了模板的概念。

每个容器都有一个单一的定义，比如**向量**,可以定义许多不同类型的向量，比如**vector<int>**或**vector<string>**。

### 函数模板

```c++
template <class type> ret-type func-name(parameter list){
    //函数的主体
}
```

在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。

### 实例

```c++
#include <iostream>
#include <string>

template <typename Ta> inline Ta const &Max(Ta const &a, Ta const &b) {
  return a < b ? a : b;
}
int main() {
  int i = 39, j = 20;
  std::cout << "Max(i, j): " << Max(i, j) << std::endl;
  double f1 = 13.5,f2 = 20.7;
  std::cout << "Max(f1, f2): " << Max(f1, f2) << std::endl;
  std::string s1 = "Hello",s2 = "World";
  std::cout << "Max(s1, s2): " << Max(s1, s2) << std::endl;
  return 0;
}

/*
Max(i, j): 20
Max(f1, f2): 13.5
Max(s1, s2): Hello
*/
```

### 类模板

也可以定义类模板。泛型类声明的一般形式如下：

```c++
template <class type> class class-name{
    
}
```

在这里，**type**是占位符类型名称，可以在类被实例化的时候进行指定。可以使用一个逗号分隔的列表来定义多个泛型数据类型。

### 示例

```c++
#include <exception>
#include <iostream>
#include <vector>
#include <cstdlib>
#include <string>
#include <stdexcept>

template <class T> class Stack {
private:
  std::vector<T> elems; // 元素
public:
  void push(T const &); // 入栈
  void pop();           // 出栈
  T top() const;        // 返回
  bool empty() const { return elems.empty(); } // 如果为空则返回真
};

template <typename T> void Stack<T>::push(T const &elem) {
  // 追加传入元素的副本
  elems.push_back(elem);
}

template <typename T> void Stack<T>::pop() {
  if (elems.empty()) {
    throw std::out_of_range("stack<>::pop():empry stack");
  }
  // 删除最后一个元素
  elems.pop_back();
}

template <typename T> T Stack<T>::top() const {
  if (elems.empty()) {
    throw std::out_of_range("stack<>::top():empty stack");
  }
  // 返回最后一个元素的副本
  return elems.back();
}

int main() {
  try {
    Stack<int> intStack;
    Stack<std::string> stringStack;
    // 操作 int 类型的栈
    intStack.push(7);
    std::cout << intStack.top() << std::endl;

    // 操作 string 类型的栈
    stringStack.push("hallo");
    std::cout << stringStack.top() << std::endl;
    stringStack.pop();
    stringStack.pop();
  } catch (std::exception &ex) {
    std::cerr << "Exception: " << ex.what() << std::endl;
    return -1;
  }
  return 0;
}

/*
7
hallo
Exception: stack<>::pop():empry stack
*/
```

## c++预处理器

预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。

所有预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是c++语句，所以它们不会以分号（；）结尾。

我们已经看到，之前所有的实实例中都有**#include**指令。这个宏用于把头文件包含到源文件中。

c++还支持很多预处理指令，比如 #include, #define, #if, #else, #line 等。

### #define预处理

（#define）预处理指令用于创建符号常量。该符号常量通常称为**宏**，指令的一般形式是：

```c++
#define macro-name replacement-text
```

当一行代码出现一个文件中，在该文件中后续出现的所有都将会在程序编译之前被替换为 replacement-text 。例如：

```c++
#include <iostream>
#define PI 3,14159
int main(){
    std::cout << "Value of PI: " << PI << std::endl;
    return 0;
}
```

### 参数宏

使用 （#define）来定义一个带有参数的宏：

### 实例

```c++
#include <iostream>
#define MIN(a, b) (a < b ? a : b)

int main() {
  int i = 100, j = 30;
  std::cout << "较小的值为： " << MIN(i, j) << std::endl;
  return 0;
}

/*
较小的值为： 30
*/
```

### 条件编译

有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。

条件预处理器的结构与 If 选择结构很像。

```c++
#ifnder NULL
	#define NULL 0
#endif
```

### 实例

```c++
#include <iostream>
#define DEBUG
#define MIN(a, b) (((a) < (b)) ? a : b)

int main() {
  int i = 100, j = 30;

#ifdef DEBUG
  std::cerr << "Trace: lnside main function" << std::endl;
#endif

#if 0
//这是注释部分
std::cout << MKSTR(HELLO C++) << std::endl;
#endif
  std::cout << "The minimun is" << MIN(i, j) << std::endl;
#ifdef DEBUG
  std::cerr << "Trace: Coming out of main function" << std::endl;
#endif
  return 0;
}

/*
Trace: lnside main function
The minimun is30
Trace: Coming out of main function
*/
```

### (# 和 ##运算符)

（#）和 （##）预处理运算符在 c++和 ANSI/ISO C 中都是可用的。（#）运算符符会把 replacement-text 令牌转换为用引导引起来的字符串。

### 实例

```c++
#include <iostream>
#define MKSTR(x) #x

int main(){
    std::cout << MKSTR(HELLO C++) << std::endl;
    return 0;
}

//HELLO C++
```

当 CONCAT 出现在程序中时，它的参数被连接起来，并用来取代宏。例如：

```c++
#include <iostream>
#define concat(a, b) a ## b

int main(){
    int x=30, y = 100;
    std::cout << concat(x, y);
    return 0;
}
// 100
```

### c++中的预定义宏

| 宏     | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| _LINE_ | 这会在程序编译时包含当前行号。                               |
| _FILE_ | 这会在程序编译时包含当前文件名。                             |
| _DATE_ | 这会包含一个形式为 month/day/year的字符串，它表示把源文件转换为目标代码的日期。 |
| _TIME_ | 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。 |

### 实例

```c++
#include <iostream>

int main() {
  std::cout << "Value of __LINE__ : " << __LINE__ << std::endl;
  std::cout << "Value of __FILE__ : " << __FILE__ << std::endl;
  std::cout << "Value of __DATE__ : " << __DATE__ << std::endl;
  std::cout << "Value of __TIME__ : " << __TIME__ << std::endl;

 return 0;
}

/*
Value of __LINE__ : 4
Value of __FILE__ : htests.cpp
Value of __DATE__ : Dec  3 2022
Value of __TIME__ : 21:55:34
*/
```

## c++信号处理

信号是由操作系统传给进程的终端，会提早终止一个程序。在  UNIX、LINUX、mac OSX 或 Windows系统上，可以通过按 CTRL+C产生中断。

有些信号不能被程序捕获，但是有些信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 c++ 头文件 <csignal>中。

| 信号    | 描述                                       |
| ------- | ------------------------------------------ |
| SIGABRT | 程序的异常终止，如调用 **abort**           |
| SIGFPE  | 错误的算术运算，比如除以零或导致溢出的操作 |
| SIGILL  | 检测非法指令                               |
| SIGINT  | 接受到交互注意信号                         |
| SIGSEGV | 非法访问内存                               |
| SIGTERM | 发送到程序的终止请求                       |

### signal()函数

c++ 信号处理库提供了 **signal**函数，用来捕获突发事件。以下是 signal() 函数的语法：

```c++
void (*signal (int sig, void (*func)(int))) (int);
```

这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。

c++程序，使用 signal() 函数捕获 SIGNT 信号。不管想在程序中捕获什么信号，都必须使用 **signal**函数来注册信号，并将其与信号处理程序相关联。

### 实例

```c++
#include <iostream>
#include <csignal>

void signalHandler(int signal) {
  std::cout << "Interrupt signal (" << signal << ") received" << std::endl;
  // 清理并关闭      终止程序

  exit(signal);
}

int main() {
  // 注册信号 SIGINT 和信号处理程序
  std::signal(SIGINT, signalHandler);
  while (1) {
    std::cout << "Going to sleep..." << std::endl;
    sleep(1);
  }
  return 0;
}

/*
Going to sleep...
Going to sleep...
Going to sleep...
Going to sleep...
Going to sleep...
Interrupt signal (2) received
^C#                            
*/
```



### raise()函数

可以使用函数 raise() 生成信号，该函数带有一个整数信号编号作为参数， 语法如下：

```c++
int raise(std::signal sig);
```

在这里，**sig**是要发送的信号的编号，这些信号包括：SIGIT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。使用 raise() 函数内部生成信号的实例：

### 实例

```c++
#include <iostream>
#include <csignal>

void signalHandler(int signum) {
  std::cout << "Interrupt signal (" << signum << ") received" << std::endl;
  // 清理并关闭      终止程序

  exit(signum);
}

int main() {
  int i = 0;
  // 注册信号 SIGINT 和信号处理程序
  std::signal(SIGINT, signalHandler);
  while (++i) {
    std::cout << "Going to sleep..." << std::endl;
    if (i == 3) {
      raise(SIGINT);
    }
    sleep(1);
  }
  return 0; 
}

/*
Going to sleep...
Going to sleep...
Going to sleep...
Interrupt signal (2) received
*/
```

## c++多线程

多线程是多任务的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务：**基于进程和基于线程**。

- 基于进程的多任务是程序的并发执行。
- 基于线程的多任务是同一个程序的片段的并发执行。

多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。

### 创建线程

例如：来创建一个POSIX线程：

```c++
#include <pthread.h>
pthread_create (thread, attr, start_routine, arg);
```

在这里，**pthread_create**创建一个新的线程，并让它可执行。

| 参数          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| thread        | 指向线程标识指针                                             |
| attr          | 一个不透明的属性对象，可以被用来设置线程属性。可以指定线程对象，也可以使用默认值 NULL |
| start_routine | 线程运行函数起始地址，一旦线程被创建就会执行。               |
| arg           | 运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 |

创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。

### 终止线程

使用如下程序，可以用它来终止一个 POSIX 线程：

```c++
#include <pthread.h>
pthread_exit (status);
```

在这里，**pthread_exit**用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。

如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。

### 实例

```c++
#include <iostream>
#include <pthread.h>

#define NUM_THREADS 5

// 线程的运行函数
void* say_hello(void* args) { std::cout << "Hello Runoob!" << std::endl; return 0; }

int main() {
	// 定义线程的 id 变量，多个变量使用数组
	pthread_t tids[NUM_THREADS];
	for (int i = 0; i < NUM_THREADS; ++i) {
		//参数依次是：创建那的线程 id ，线程参数，调用的函数，传入的函数参数
		int ret = pthread_create(&tids[i], NULL, say_hello, NULL);
		if (ret != 0) {
			std::cout << "pthread_create error: error_code= " << ret << std::endl;
		}
	}
	//等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来
	pthread_exit(NULL);
	return 0;
}

/*
Hello Runoob!
Hello Runoob!
Hello Runoob!
Hello Runoob!
Hello Runoob!
*/
```

以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，并接收传入的参数。每个线程打印一个 “Hallo Runoob！” 消息，并输出接收的参数，然后调用 pthread_exit() 终止线程。

```c++
#include <cstdlib>
#include <iostream>
#include <pthread.h>

using namespace std;
#define NUM_THREADS 5
void *PrintHello(void *threadid) {
  // 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取
  int tid = *((int *)threadid);
  cout << "Hello Runoob! 线程 ID, " << tid << endl;
  pthread_exit(NULL);
}
int main() {
  pthread_t threads[NUM_THREADS];
  int indexes[NUM_THREADS]; // 用数组来保存i的值
  int rc;
  int i;
  for (i = 0; i < NUM_THREADS; i++) {
    cout << "main() : 创建线程, " << i << endl;
    indexes[i] = i; // 先保存i的值
    // 传入的时候必须强制转换为void* 类型，即无类型指针
    rc = pthread_create(&threads[i], NULL, PrintHello, (void *)&(indexes[i]));
    if (rc) {
      cout << "Error:无法创建线程," << rc << endl;
      exit(-1);
    }
  }
  pthread_exit(NULL);
}

/*
main() : 创建线程, 0
main() : 创建线程, 1
main() : 创建线程, 2
Hello Runoob! 线程 ID, 1
main() : 创建线程, 3
Hello Runoob! 线程 ID, 2
main() : 创建线程, 4
Hello Runoob! 线程 ID, 3
Hello Runoob! 线程 ID, 4
*/
```

### 向线程传递参数

可以在线程回调中传递任意的数据类型，因为它指向 void，所示：

### 实例

```c++
#include <iostream>
#include <cstdlib>
#include <pthread.h>

#define NUM_THREADS 5

struct thread_data {
  int thread_id;
  char *message;
};

void *PrintHello(void *threadarg) {
  struct thread_data *my_data = (struct thread_data *)threadarg;
  std::cout << "Thread ID : " << my_data->thread_id 
            << "Message: " << my_data->message << std::endl;
  pthread_exit(NULL);
}

int main() {
  pthread_t threads[NUM_THREADS];
  struct thread_data tdata[NUM_THREADS];
  int rc, i;
  for (i = 0; i < NUM_THREADS; i++) {
    std::cout << "main(): creating thread, " << i << std::endl;
    tdata[i].thread_id = i;
    tdata[i].message = (char *)"This is message";
    rc = pthread_create(&threads[i], NULL, PrintHello, (void *)&tdata[i]);
    if (rc) {
      std::cout << "Error: unable to create thread," << rc << std::endl;
      exit(-1);
	}
  }
  pthread_exit(NULL);
  return 0;
}

/*
main(): creating thread, 0
main(): creating thread, 1
Thread ID : 0  Message: This is message
Thread ID : 1  Message: This is message
main(): creating thread, 2
main(): creating thread, 3
Thread ID : 2  Message: This is message
main(): creating thread, 4
Thread ID : 3  Message: This is message
Thread ID : 4  Message: This is message
*/
```

### 连接和分离线程

可以使用以下两个函数来连接或分离线程：

```c++
pthread_join (threadid, status);
pthread_detach (threadid);
```

pthread_jojn() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止。当创建一个线程时，它的某个属性会定义是否可连接的 （jojnable）或可分离的 （detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。

### 实例

