# CRUD 操作

## 添加约束

1. 什么是约束？

约束的作用就是为了保证：表中的数据有效！！！

2. 约束包含哪些？

- 非空约束： not null  只能咧级约束，没有表级约束！
- 唯一性约束：unique   或  联合唯一约束 unique()
- 主键约束： primary key
- 外键约束：foreign key
- 检查约束：check（mysql不支持，oracle 支持）

### 非空约束

not null

语法：

```mysql
drop table if exists t_value;
create table t_value (
    id int,
    name varchar(26) not null
);

insert into t_value(id,name) values(1,'zhangsan'),(2,'lisi');
```

### 唯一约束

unique

唯一性约束 unique 约束的字段不能重复，但是可以为 null。

语法：

```mysql
drop table if exists t_value;
create table t_value (
    id int unique,
    name varchar(26) unique
);

mysql> desc t_value;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int         | YES  | UNI | NULL    |       |
| name  | varchar(26) | YES  | UNI | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

insert into t_value(id,name) values(1,'zhangsan'),(2,'lisi');


联合唯一
drop table if exists t_value;
create table t_value (
    id int unique,
    name varchar(26),
    email varchar(26),
    unique(name,email)
);

mysql> desc t_value;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int         | YES  | UNI | NULL    |       |
| name  | varchar(26) | YES  | MUL | NULL    |       |
| email | varchar(26) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)

insert into t_value values(1,'zhangsan','ahansan@qq.com'),
                          (2,'lisi','lisi@qq.com');
+------+----------+----------------+
| id   | name     | email          |
+------+----------+----------------+
|    1 | zhangsan | ahansan@qq.com |
|    2 | lisi     | lisi@qq.com    |
+------+----------+----------------+
2 rows in set (0.00 sec)


insert into t_value values(3,'lisi','lisi@googe.com');
+------+----------+----------------+
| id   | name     | email          |
+------+----------+----------------+
|    1 | zhangsan | ahansan@qq.com |
|    2 | lisi     | lisi@qq.com    |
|    3 | lisi     | lisi@googe.com |
+------+----------+----------------+
3 rows in set (0.00 sec)


注意：只有当两个内容一致才导致失败
mysql> insert into t_value values(4,'lisi','lisi@googe.com');
ERROR 1062 (23000): Duplicate entry 'lisi-lisi@googe.com' for key 't_value.name'
```

### unique和not null约束联合使用

```mysql
drop table if exists t_value;
create table t_value (
    id int,
    name varchar(26) not null unique
);

mysql> desc t_value;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int         | YES  |     | NULL    |       |
| name  | varchar(26) | NO   | PRI | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
```

注意：在 mysql 当中，如果一个字段同时被 not null 和 unique 约束的话，该字段自动变成主键字段。（但是在 oracle 中不一样！）。

#### 主键约束

任何一张表应该有主键，没有主键，表无效！！

主键不能是 null， 同时也不能重复！

```mysql
drop table if exists t_value;
create table t_value (
    id int primary key,
    name varchar(26)
    primary key(id) // 此操作是表级约束
);

mysql> desc t_value;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int         | NO   | PRI | NULL    |       |
| name  | varchar(26) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)


联合主键 或 复合主键
drop table if exists t_value;
create table t_value (
    id int,
    name varchar(26),
    email varchar(26),
    primary key(id, name)
);

mysql> desc t_value;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int         | NO   | PRI | NULL    |       |
| name  | varchar(26) | NO   | PRI | NULL    |       |
| email | varchar(26) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```

#### 外键

语法：

```mysql
foreign key(字段) references 父表名(字段) 

Create Table: CREATE TABLE `dept_emp` (
  `emp_no` int NOT NULL,
  `dept_no` char(4) NOT NULL,
  `from_date` date NOT NULL,
  `to_date` date NOT NULL,
  PRIMARY KEY (`emp_no`,`dept_no`),
  KEY `dept_no` (`dept_no`),
  CONSTRAINT `dept_emp_ibfk_1` FOREIGN KEY (`emp_no`) REFERENCES `employees` (`emp_no`) ON DELETE CASCADE,
  CONSTRAINT `dept_emp_ibfk_2` FOREIGN KEY (`dept_no`) REFERENCES `departme` (`dept_no`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
```

## 刷题笔记

1. 在一个er图中，有四个实体集，两个二元一对多联系，两个二元多对多联系，一个三元多对多联系，两个一元多对多联系，则将该er图转换为关系模型后，得到的关系模式数是（==参考 9 个==）。

解释：

​	er 图向关系模式转换涉及到两个方面： 1、实体的转换； 2、实体间联系的转换；

​	实体的转换：在从er图转换为关系模式时，一个实体就转换一个关系模式，实体的属性就是关系模式的属性，实体的键就是关系的主键。

​	实体间联系的转换：实体间存在三种联系，即1:1（一对一），1：n（一对多），m：n（多对多）。

- 1:1（一对一）联系

  - 方法一：联系转换为独立的关系模式；模式的属性由联系本身的属性及两个实体的键构成；主键由两个实体中的任意一个键成。
  - 方法二：联系与一端的实体的关系模式合并，即将联系的属性假加入到实体的关系模式内，主键不变。

- 1:n（一对多）联系

  - 方法一：联系转换为独立的关系模式，模式的属性由联系本身的属性及实体的键构成；主键由n端实体的键构成。
  - 方法二：与n端的实体的关系模式合并，即将联系的属性加入到实体的关系模式内，主键不变。

- m:n（多对多）

  - 联系转换成新的独立模式，模式的属性由本身的属性及两个实体的键构成，主键由两端实体的键组合成。

  有题目可知，该题中有四个实体，两个二元一对多联系，两个二元多对多联系，一个三元多对多联系，两个一元多对多联系。4个实体和5个m:n（多对多）联系可以转换为单独的模式，1:n（一对多）联系需要合并到实体中去。

2. 在 IDEFO 需求建模方法中，每个功能活动可以用带箭头的矩形框表示，其中 左边的输入箭头表示完成活动需要的数据；矩形框上方的控制箭头描述了影响这个活动执行的事件或约束事件；右边的输出箭头说明由活动产生的结果及信息；下方进入的机制箭头表示实施该活动的物理手段或完成活动需要的资源。
3. 从功能角度 DBAS 系统通常可以划分为四个层次实现：
   1. 表示层：负责所有与用户交互的功能，用户对数据库应用系统的最直观感受均在这层实现。
   2. 业务逻辑层：负责根据业务逻辑需要将表示层获取的数据进行组织后，传递给数据访问层，或将数据访问层获取的数据进行相应的加工处理后，传递给表示层用于展示。
   3. 数据访问层：负责与 DBAS 系统进行交互，提取或存入应用系统所需的数据。
   4. 数据持久层：负责保存和管理应用 应用系统数据。
4. 在 uml 中，用类图来描述系统的静态结构，而用顺序图和通信图来表示系统的动态结构。
   1. 类图主要表达的是问题领域的概念模型，在这个抽象的概念中，除了表达该抽象概念的名称外，另外需要表达该抽象概念的“属性”和“行为”。
   2. 顺序图的目的在于说明对象的协作如何达到系统的目标，主要用于描述系统内对象的消息发送和接收序列。
   3. 顺序图是交互图的一种，也被称为协作图。通信图中包含一组对象，并在图中展示这些对象之间的联系以及对象间发送和接收的消息。
   4. 顺序图和通信图都都描述交互，但是顺序图强调的是时间，通信图强调的是空间。
5. 数据库的完整性约束条件分为三种级别：
   1. 对列的约束：对其值的类型、范围、精度、排序等约束。
   2. 对元组的约束：对记录中各个属性之间的联系约束。
   3. 对关系的约束：对若干记录间（一个关系的各个元组之间）、关系集合上以及关系之间联系的约束。
6. 使用 for 或者 after 选项定义的触发器为后触发型触发器，即只有在引发触发器执行的语句中的操作都已成功执行，并且所有的约束检查也成功完成后，才执行该触发器。使用 instead of 选项定义的触发器为前触发型触发器，在这种模式的触发器中，指定执行触发器而不是执行引发触发器执行的 sql 语句，从而替代触发的操作。

```mysql
create trigger tri_1 on t1 for update as .....
```

7. 使用 FOR 或者 ARTER 选项定义的触发器为后触发型触发器，即只有在引发触发器执行的雨具中操作都已成功执行，并且所有的约束检查也成功完成后，才执行该触发器。使用 INSTEAD OF 选项定义的触发器为前触发型触发器，在这种模式的触发器中，指定执行触发器而不是执行引发触发器执行 SQL 语句，从而替代触发的操作。 

8. 使用 INSTEAD OF 选项定义的触发器为前触发器。在这种模式的触器中，指定执行触发器执行的SQL语句，从而替代触发的操作。在一个表上可以建立多个名称不同、类型各异的触发器，每个触发器可由三个操作来引发。对于前触发器，`在一个表上针对同一个数据操作只能定义一个前触发器`；对于后触发器，可以在同一中操作上建立多个触发器。

9. SQL server游标中 FETCH 语句的定义：

   1. FETCH 语句用于从游标中检索下一行的数据。它的语法如下：

      ```mysql
      FETCH NEXT FROM cursor_name INTO variable_list;
      
      # cursor_name是游标的名称；
      # variable_list 是一个或多个变量，用于存储从游标中检索到的数据。
      ```

   2. FETCH 语句将游标移动到下一行，并将该行的数据存储到指定的变量中。如果没有更多的行可用，FETCH 语句将返回一个空结果集。

   3. FETCH 语句还可以使用其他选择项，列如： FETCH FIRST 和 FETCH LAST，用于检索第一行或最后一行数据。例如: 

   ```mysql
   FETCH FIRST FROM cursor_name INTO variable_list;    # 检索第一行
   FETCH LAST FROM cursor_name INTO variable_list;		# 检索最后一行
   ```

   10. model 数据库用作 SQL Server 实例上的所有数据库的模板。对 model 数据库进行的修改（如数据库大小、排序规则、恢复模式和其他数据库选项）将应用用于以后创建的所有用户数据库，当用户创建一个数据库时，系统自动将 model 数据库中的全部内容复制到新建数据库中。

   11. 授权语句格式是 `“GRANT 可以授予的权限 ON 表名 TO 用户名”`，授权时一个语句可以授予多个权限，也可以一次授予一个权限。

   12. oracle 的安全控制机制可以分为数据库级的安全控制、表级、行级和列级的安全控制。数据库级的安全型通过身份认证和授予用户相应系统权限来保证，而表级、行级、列级的安全性是通过授予或回收对象的特权保证的。oracle 数据库中的用户按其操作权限大小可分为 DBA 用户和普通用户。

   13. DBAS 需求分析阶段的一项重要工作是分析 DBAS 应具有的性能指标，主要包括：

       1. 数据操作响应时间，或数据访问响应时间；
       2. 系统吞吐量，即指系统在单位时间内可以完成的数据库事务或查询的数量。
       3. 允许并发访问最大用户数。
       4. 每 TPS (Price per TPS)代价值。

   14. 在数据库操作中，为了有效保证并发读取数据的正确性，提出的事务隔离级别。数据库物理设计的目的是将数据的逻辑描述转换为实现技术规范，其目的是设计数据存储方案，以便提供足够好的性能并确保数据库的数据完整性、安全性和可恢复性。设置事务执行的隔离级别，该任务属于数据应用系统设计步骤中的物理设计。

   15. 数据流图(Data Flow Diagram, 简称 DFD) 是便于用户理解系统数据流程的图形表示。DFD 建模方法的核心是`数据流`，它能精确地在逻辑上描述系统的功能、输入、输出和数据存储等。从而摆脱了其物理内容。数据流图是系统逻辑模型的重要组成部分。

       1. 抽象性： 在 DFD 中具体的组织机构、工作场所、物理流等都已经去掉，只剩下信息和数据存储、流动、使用以及加工的情况。所以描述的是抽象出来的数据。
       2. 概括性：它把系统对各种业务的处理过程联系起来考虑，形成一个总体，可反映出数据之间的概括情况。

   16. 在 DFD 建模方法中，`数据流用箭头表示、处理用矩形表示、数据存储用圆角矩形表示、外部项用圆角框或者平行西变形表示`。

   17. DFD 方法由四种基本元素（模型对象）组成：`数据流、处理、数据存储和外部项`。

   18. 数据库系统设计分为6个阶段：需求分析、概念机构设计、逻辑结构设计和物理结构设计等

   19. 数据模型三个要素包括：

       1. 数据结构：数据结构是所研究的对象类型的集合。它从语法角度表述了客观世界中数据对象本身的结构和数据对象之间的关联关系，是对系统静态特征的描述。
       2. 数据操作：数据操作是对数据库中对象的实例预见性执行的操作的集合，主要指检索和更新（插入(insert)、删除()delete)、修改(update)）两类操作。数据模型必须定义这些操作的确切含义、操作符号、操作规则（如优先级）以及实现操作的语言。数据操作是对系统动态特性的描述。
       3. 数据完整性约束：数据完整性约束是一组完整性的规则的集合，规则数据库状态及状态变化所应满足的条件，以保证数据的正确性，有效性和相容性。

   20. 一个数据文件上可以建立多个索引文件。如果数据文件中数据记录的排列顺序与索引文件中索引项的排列顺序一致，则称为该文件为聚集索引，否则称为非聚集索引。一个数据文件上只能建立一个聚集索引，可以建立多个非聚集索引。

   21. 建立索引是加快查询速度的有效手段。在 SQL 语言中，建立索引使用 CREATE INDEX 语句，一般格式为：

       ```mysql
       create [unique] index <索引名> on <表名> (<列名>[<次序>]) include (属性名) where 约束条件
       
       例如：
       	create index idx1 on emp(id) include (name,age) where tname = name or tname = name;
       ```

   22. 用户定义的完整性可以用 CHECK 短语指定列值应满足的条件，也可以用触发器约束，通过服务器自动激活相应的触发器，对数据进行完整性控制。所以触发器或 CHECK 约束都可以实现。但 DEFAULT 约束不能实现用户自定义的完整性，只能表示实体或参照完整性。

   23. with ties 一般是和 top、order by 相结合使用，表示包括与最后一行 order by 后面的参数取值并列的结果。

   24. 概念数据模型主要用来描述数据的概念化结构，它使数据库设计人员的初始阶段摆脱计算机系统及 DBMS 的具体技术问题，集中精力分析数据以及数据之间的联系等，与具体的数据库管理系统无关，所以没有描述数据的完整性约束条件。

   25. 函数依赖的定义为：设 R(U) 是属性集 U 上的关系模型 X,Y 是 U 的子集，若对 R(U) 的任意一个可能的关系 r，r 中不可能存在两个元组 X 上属性值相等，而在 Y 上的属性值不等，则称 X 函数确定 Y 或 Y 函数定义依赖于 Y 。其本质是根据属性间的依赖情况来判定关系是否具有模型不合适的性质。

   26. 触发器是用户定义在关系表上的一类由时间驱动的特殊过程。一旦定义，任何用户对表的增、删，改操作均由服务器自动激活相应的触发器，在 DBMS 核心层进行集中的完整性控制，类似于约束。前触发型触发器只执行触发器指定的内容不执行引发触发器的 SQL 语句，为职工表中插入数据设定一个非工作时间的前触发型触发器后就可以实现改功能。

   27. 在进行数据恢复时，首先恢复完全备份，其次恢复差异备份，最后恢复日志备份。备份日志时使用 Norecovery 用来备份尾日志，这样备份日志的时候数据库处于恢复状态，别的进程就不能在再访问数据库，日志就不再增加，因此在还原的时候就可以正常恢复。还原备份的时候如果想同时还原之后的日志，必须加上 Norecovery 才可以还原，如果有多个日志备份，除了最后一个日志备份外，还原其他日志也必须加上 Norecovery。

   28. master 数据库是 SQL server 系统里面最重要的数据库，因为它包含了系统中的有关数据库的所有信息。对 master 数据库只能进行完全数据库备份操作，SQL server 不支持 master 数据亏上进行差异备份，事务日志备份以及文件备份。

   29. 并行数据库系统的主要目的是通过高索通信介质连接多个可独立处理的单元以并行执行的方式完成对数据库系统的互联查询、内部查询及各种内部操作。分布式数据库系统的主要目的是实现现场地自治和数据全局透明共享。

   30. 分布式数据库的分配方式包括`集中式、分割式、权复制式、混合式`。集中是指所有数据片断都安排在一个场地上；分割是指全局数据有且只有一份，它们被分割成若干片段，每个片段被分配在一个特定场地上；全复制式是在每个站点上都有全局数据的复制样本，数据的冗余性最大；混合式指全局数据被分为若干个数据子集，每个子集被安排在一个或多个不同的场地上，但是每个场地未必保存所有数据。

   31. OLTP 是对数据库联机的日常操作，通常是对一条记录的查询和修改，要求快速响应用户的请求，对数据的安全性，完整性及事物的吞吐量要求很高。而 OLAP 是对数据的查询和分析操作，通常是对海量历史数据的查询和分析，要访问的数据量非常大，查询和分析操作十分复杂。又因为 OLAP 为宏观分析， OLTP 为微观操作，所以前者(OLAP)面向中上层和决策使用，而后者(OLTP)面向企业下层业务人员使用。

   32. 由于有样本集和测试集之分，又有已有的类别标签，所以属于监督学习。分类：通过学习得到一个目标函数 f，把每个属性集 x 映射到一个预先定义的类标号y。分类属于监督学习。聚类：根据在数据中发现的描述对象及其关系的信息，将数据对象分组，组内的对象互相之间是相似的，而不同组中的对象则不同。组内的相似性越大，组间差别越大，聚类就越好，属于无监督学习。管理规则挖掘：发现隐藏在大型数据集中的有意义的联系。多维分析是只各级管理决策人员从不同的角度、快速灵活地对数据仓库中的数据进行复杂的查询多维分析处理。

   33. 对模式进行分解时，即保证分解语句具有“无损连接”，有要保证分解“保持函数依赖”。所谓“无损连接”指分解的若干连接重组时可以精确恢复到原来的数据库，数据记录既没有增加也没有减少。“保持函数依赖”是指原关系模式含有的属性之间的隐含关系在分解后不能丢失。

   34. 为了提高系统的性能，应该根据应用情况将数据的易变部分和稳定部分、经常存取部分和存取频率较低的部分分开存饭，较常用的放在高速读写的磁盘上，但并没有说索引一定要在高速磁盘，日志一定要在低速磁带，要根据访问频率决定。

   35. 三层架构将更多的任务传给服务器端计算，所以增加了网络的通信量，其运行速度受制于网络，并不一定会提高。在使用 internet、维护工作等方面，B/S 比 C/S 强；在运行速度，数据安全，人机交互等方面，不如 C/S。

       - C/S 架构是一种典型的两层架构，其全称是 Client/Server,即客户端或服务端架构。
    - B/S 架构的全称为 Brower/server，即浏览器或服务器架构。
   
36. 关系数据语言分为关系代数语言、关系演算语言和兼具两者双重特点的语言，如 SQL，但所有这些语言的共同特点是非过程的集合操作语言。
   
37. 类的 UML 表示（空心三角实线连接）、接口的 UML 表示（空心三角虚线连接）、聚合关系的 UML 表示（空心菱形实线连接）以及合成关系的 UML 表示（实心菱形实线连接）。类的标识指的是子类对父类关系的继承；接口与子类继承比较相似，区别主要在于多继承上；聚合关系主要表示一种弱的拥有关系，如 a 对象包含 b 对象，但 b 对象不是 a 对象的一部分；而合成是一种强拥有，体现了严格的部分和整体关系。
   
38. SQL 中 case where 语句的用法。
   
       1. case 函数，其语法格式如下：
      
       2. ```mysql
          case
          	where 布尔表达式1 then 结果表达式1
          	where 布尔表达式2 then 结果表达式2
          end
          
          # 示例：
          
          case 
          	where grade between 90 and 100 then '优秀'
          ```
    
       	......
       	  end
      ```
      
      ```
   
39. 架构是形成单个命名空间的数据库实体的集合。命名空间也是一个集合，其中每个元素的名称都是唯一的。架构与用户的关系是一对多的关系，一个用户只能对应一个架构，但是多个用户可以共享一个架构。
   
40. SQL server Agent 是一个任务规划和警报管理器，在实际应用环境下，可以先将哪些周期性的活动定义成一个任务，然后让其在 SQL server Agent 的帮助下自动运行。加入考生是一名系统管理员，则可以利用 SQL server Agent 向自己通知某些警告信息，从而定位出现的问题以提高管理效率。SQL server Agent 主要包括以下几个组件：作业、警报、和操作。
   
41. SQL server 示例就是在数据库中存在的现实的数据库例子，它是后台进程和数据库文件的集合。仅具有登录权限的用户对 SQL server 只能进行 系统数据库中有关 SQL server 的一些系统信息的查询，即只能对 master、msdb 数据库部分数据进行查询。
   
42. 检测死锁有多种方法、包括超时法、等待图法等。事务等待图法动态地反映了所有事务的等待情况，并发控制的子系统周期性地生成事务等待图进行检测，而不是在执行每个事务时进行检测。
   
43. 元数据是关于数据的数据，或者叫做描述数据的数据。元数据描述了数据的结构、内容、链和索引等项内容。在关系数据中，这种描述就是对数据库、表、列等其他对象的定义。
   
44. 建立索引是加快查询速度的有效手段。用户可以根据应用环境的需要，在基本表上建立一个或多个索引，以提供多种存取路径，加快查找速度。聚集索引是指索引的顺序与表中记录的物理顺序一致的索引组织。
   
   45. 数据模型的三个要素包括：
   
       1. 数据结构
          - 数据结构是所研究的对象类型的集合。它从语法角度表述了客观世界中数据对象本身的结构和数据对象之间的关联关系，是对系统静态特征的描述。
       2. 数据操作
       - 数据操作是对数据库中的对象的实力允许执行的操作的集合，主要指检索和更新（插入，删除，修改）两类操作。数据模型必须定义这些操作的确切含义、操作符号、操作规则（如优先级）以及实现操作的语言。数据操作是对系统动态特征的描述。
       3. 数据完整性的约束
       - 数据完整性约束是一组完整性规则的集合，规定数据库状态及状态变化所应满足的条件，以保证数据的正确性、有效性和相容性。
   
46. 结构图是指以模块的调用关系为线索，用自上而下的连线表示调用关系并注明参数传递的方向和内容，从宏观上反映模块层次结构的图形。其中结构图包括图，复合结构图，类图，组件图，对象图和部署图。
   
47. 关系表在逻辑上有一系列元组组成，元组又多个属性组成。每个元组可以用数据库磁盘文件中的一个逻辑记录来存储，记录包括多个域。元组的每个属性对应于文件记录中的一个域。
   
   48. 多表连接的类型主要有 `left join, right join 和 inner join`。其主要区别如下：
   
        1. left join（左连接），返回包括左表中的所有记录和右表中联结字段相等的记录；
       2. right join（右连接），返回包括右表中的所有记录和左表中联结字段相等的记录；
        3. inner join（等值连接），只返回两个表中联结字段相等的行。
   
49. 事务日志是一个与数据库文件的文件。它存储对数据库进行的所有更改，并记录全部插入、更新、删除、提交、回退和数据库模式变化等操作。事务日志是数据备份和数据恢复的重要文件，也是使用 SQL remote 或 复制代理，复制数据所必需的。
   
50. 数据字典是指对数据的数据项，数据结构，数据流，数据存储，处理逻辑，外部实体等进行定义和描述，其目的是对数据流程图中的各个元素做出详细的说明。数据字典一般由数据库管理系统本身管理和维护。
   
25. 确立粒度的原则：细化程度越高，粒度越小；细化程度越低，粒度越大，综合程度越高。

26. 时间序列分析也可以称为数据演变分析，描述行为对象随时间变化的规律或趋势，并进行建模的数据挖掘方法。

27. 分布式数据要达到的目标是：本地自治，非集中式管理，高可用性，位置独立性，数据分片独立性，数据复制独立性，分布式事务管理，硬件独立性，操作系统独立性，网络独立性，数据库管理系统独立性。并行数据库的目标是高性能和高可用，通过多个处理节点并行执行数据库任务，提高整个数据库系统的性能和可用性。

28. 包含 into 子句的 select 语句的语法格式为： select 查询列表序列 into<新表名> from 数据源。

29. ODS 是数据仓库体系结构中的一个可选部分，ODS 具备数据仓库的部分特征和 OLTP 系统的部分特生，它是‘面向主题的，集成的，当前或接近当前的，不断变化的’数据。第一类 ODS 数据更新频率是秒级，第二类 ODS 的数据更新频率是小时级，第三类 ODS 的数据更新频率是天级。

30. sql server 2008中，创建登录账户的语句是：`create login 登录名...`。

31. 在数据分析方法中，将一组数据对象采取一定方法划分成若干个组，并使组内数据对象尽可能相似，组间对象可能不同的过程称为 `聚类`。

32. 共享内存结构中所有的处理机通过互联网共享要给公共的主存储器；共享磁盘结构中所有处理机拥有独立的主存储器，通过无共享结构中的每个处理机拥有独立的主存储器和磁盘，不共享任何资源。层次结构综合了共享内存，共享磁盘和无共享结构的特点。

33. 

    

    

    

       

       

​	



