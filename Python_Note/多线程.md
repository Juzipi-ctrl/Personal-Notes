## python3多线程

多线程类似于同时执行多个不同程序，多线程运行有如下优点：

- 使用线程可以把占据长时间的程序中的任务放到后台去处理。
- 用户界面可以更加吸引人，比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。
- 程序的运行速度可能加快。
- 在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们可以释放一些珍贵的资源如内存占用等等。

每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。

指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。

- 线程可以被抢占（中断）。
- 在其他线程正在运行时，线程可以暂时搁置（也称为睡眠） -- 这就是线程的退让。

线程可以分为:

- **内核线程：**由操作系统内核创建和撤销。
- **用户线程：**不需要内核支持而在用户程序中实现的线程。

Python3 线程中常用的两个模块为：

- **_thread**
- **threading(推荐使用)**

thread 模块已被废弃。用户可以使用 threading 模块代替。所以，在 Python3 中不能再使用"thread" 模块。为了兼容性，Python3 将 thread 重命名为 "_thread"。



### python线程

Python中使用线程有两种方式：函数或者用类来包装线程对象。

函数式：调用 _thread 模块中的start_new_thread()函数来产生新线程。语法如下:

```python
_thread.start_new_thread ( function, args[, kwargs] )
```

参数说明：

- function - 线程函数。
- args - 传递给线程函数的参数,他必须是个tuple类型。
- kwargs - 可选参数。

```python
#!/usr/bin/python3

import _thread
import time

# 为线程定义一个函数
def print_time( threadName, delay):
   count = 0
   while count < 5:
      time.sleep(delay)
      count += 1
      print ("%s: %s" % ( threadName, time.ctime(time.time()) ))

# 创建两个线程
try:
   _thread.start_new_thread( print_time, ("Thread-1", 2, ) )
   _thread.start_new_thread( print_time, ("Thread-2", 4, ) )
except:
   print ("Error: 无法启动线程")

while 1:
   pass
```

### 线程模块

Python3 通过两个标准库 _thread 和 threading 提供对线程的支持。

_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。

threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法：

- **threading.current_thread()**: 返回当前的线程变量。

- **threading.enumerate()**: 返回一个包含正在运行的线程的列表。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。

- **threading.active_count()**: 返回正在运行的线程数量，与 len(threading.enumerate()) 有相同的结果。

- threading.Thread(target, args=(), kwargs={}, daemon=None)

  ：

  - 创建`Thread`类的实例。
  - `target`：线程将要执行的目标函数。
  - `args`：目标函数的参数，以元组形式传递。
  - `kwargs`：目标函数的关键字参数，以字典形式传递。
  - `daemon`：指定线程是否为守护线程。

threading.Thread 类提供了以下方法与属性:

1. **`__init__(self, group=None, target=None, name=None, args=(), kwargs={}, \*, daemon=None)`：**
   - 初始化`Thread`对象。
   - `group`：线程组，暂时未使用，保留为将来的扩展。
   - `target`：线程将要执行的目标函数。
   - `name`：线程的名称。
   - `args`：目标函数的参数，以元组形式传递。
   - `kwargs`：目标函数的关键字参数，以字典形式传递。
   - `daemon`：指定线程是否为守护线程。
2. **`start(self)`：**
   - 启动线程。将调用线程的`run()`方法。
3. **`run(self)`：**
   - 线程在此方法中定义要执行的代码。
4. **`join(self, timeout=None)`：**
   - 等待线程终止。默认情况下，`join()`会一直阻塞，直到被调用线程终止。如果指定了`timeout`参数，则最多等待`timeout`秒。
5. **`is_alive(self)`：**
   - 返回线程是否在运行。如果线程已经启动且尚未终止，则返回`True`，否则返回`False`。
6. **`getName(self)`：**
   - 返回线程的名称。
7. **`setName(self, name)`：**
   - 设置线程的名称。
8. **`ident`属性：**
   - 线程的唯一标识符。
9. **`daemon`属性：**
   - 线程的守护标志，用于指示是否是守护线程。
10. **`isDaemon()`方法：**



















