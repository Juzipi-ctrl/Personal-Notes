

# Docker

## 帮助命令

```shell
docker version 		# 显示 Docker 的版本信息
docker info			# 显示 Docker 的系统信息 包括镜像和容器的数量
docker 命令 --help  #	万能命令
```

查看帮助文档地址：https://docs.docker.com/engine/reference/commandline/

## 镜像命令

**docker images 查看所有本地的主机的镜像**

```shell
[root@localhost /]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED       SIZE
hello-world   latest    9c7a54a9a43c   4 weeks ago   13.3kB


# 解释
REPOSITORY	# 镜像的仓库源
TAG			# 镜像的标签
IMAGE ID	# 镜像的 id
CREATED		# 镜像的创建时间
SIZE		# 镜像的大小

# 可选项
-a, --all             # 列出所有镜像
 
 -q, --quiet          # 只显示镜像的 id
```

**docker search 搜索镜像**

```shell
[root@localhost /]# docker search mysql --filter=STARS=3000
NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql     MySQL is a widely used, open-source relation…   14180     [OK]
mariadb   MariaDB Server is a high performing open sou…   5417      [OK]
```

**docker search 搜索镜像**

```shell
[root@localhost /]# docker search --help

Usage:  docker search [OPTIONS] TERM

Search Docker Hub for images

Options:
  -f, --filter filter   Filter output based on conditions provided
      --format string   Pretty-print search using a Go template
      --limit int       Max number of search results
      --no-trunc        Don't truncate output
      
# 可选项，通过搜索来过滤
--filter=STARS=3000		# 搜索出来的镜像就是 STARS 大于 3000 的

$ sudo docker search mysql --filter=STARS=3000
NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql     MySQL is a widely used, open-source relation…   14180     [OK]
mariadb   MariaDB Server is a high performing open sou…   5417      [OK]
```

**docker pull 下载镜像**

```shell
# 下载镜像 docker pull 镜像名：[tag]
[root@localhost /]# docker pull mysql
Using default tag: latest  # 如果不写 tag ，默认就是 latest 
latest: Pulling from library/mysql
Digest: sha256:d6164ff4855b9b3f2c7748c6ec564ccff841f79a7023db0f9293143481a44b6e	# 签名
Status: Image is up to date for mysql:latest	# 真实地址
docker.io/library/mysql:latest

#等价于
sudo docker pull mysql
sudo docker pull docker.io/library/mysql:latest
```

**docker rmi 删除镜像**

```shell
# 镜像删除
sudo docker rmi -f 容器id
sudo docker rmi -f 容器id 容器id 容器id 容器id 	# 删除多个容器
# 递归删除
sudo docker rmi -f $(docker images -aq)  # 删除全部的容器

Options:
  -f, --force      Force removal of the image
      --no-prune   Do not delete untagged parents
```

## 容器命令

**说明：要有了镜像才可以创建容器，Linux 例如下载一个 centos 镜像类测试学习**

```shell
[root@localhost /]# docker pull centos
```

**新建容器并启动**

```shell
docker run [可选参数] image

# 参数说明
--name="name"		# 容器的名字 tomcat01 tomcat02 , 用来区分容器
-d					# 后台方式运行
-it					# 使用交互方式运行，进入容器查看内容
-p					# 指定容器的端口 -p 8080:8080
	-p ip:主机端口:容器端口
	-p 主机端口:容器端口（常用）
	-p 容器端口
-p					# 随机指定端口

# 查看已安装的容器
[root@localhost ~]# docker images
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
centos       latest    5d0da3dc9764   20 months ago   231MB

# 测试，启动并进入容器
[root@localhost ~]# docker run -it centos /bin/bash
[root@067b29f8a964 /]# ls	# 查看容器内的 centos，基础版本，很多命令都是不完善的！
bin  etc   lib	  lost+found  mnt  proc  run   srv  tmp  var
dev  home  lib64  media       opt  root  sbin  sys  usr

# 从容器中退回主机
[root@067b29f8a964 /]# exit
exit
[root@localhost /]# ls
bin   dev  home  lib64  mnt  proc  run   srv  tmp  var
boot  etc  lib   media  opt  root  sbin  sys  usr
```

**列出所有的运行的容器**

```shell
# docker ps  命令
		# 列出当前正在运行的容器
-a		# 列出当前正在运行的容器+带出历史运行过的容器
-n-?	# 显示最近创建的容器
-q		# 只显示容器的编号

[root@localhost /]# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
[root@localhost /]# docker ps -a
CONTAINER ID   IMAGE          COMMAND       CREATED          STATUS                        PORTS     NAMES
067b29f8a964   centos         "/bin/bash"   4 minutes ago    Exited (127) 3 minutes ago              stupefied_bassi
b4b2689ffab8   centos         "/bin/bash"   17 minutes ago   Exited (127) 13 minutes ago             cranky_almeida
6396b5da4d3e   9c7a54a9a43c   "/hello"      24 hours ago     Exited (0) 24 hours ago                 amazing_kowalevski

```

**退出容器**

```shell
exit			# 直接容器停止并退出
Ctrl + P + Q	# 容器不停止退出 或 Ctrl + d
```

**删除容器**

```shell
sudo docker rm 容器id						# 删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -f
sudo docker rm -f $(docker ps -aq)		# 删除所有的容器
sudo docker ps -a -q | xargs docker rm	# 删除所有的容器
```

**启动和停止容器的操作**

```shell
sudo docker start 容器id		# 启动容器
sudo docker restart 容器id	# 重启容器
sudo docker stop 容器id		# 停止当前正在运行的容器
sudo docker kill 容器id		# 强制停止当前容器
```

## 常用的其他命令

**后台启动容器**

```shell
# 命令 docker run -d 镜像名！
[root@localhost ~]# docker run -d centos

# 问题 docker ps , 发现 centos 停止了

# 常见的坑： Docker 容器使用后台运行，就必须要有一个前台进程，Docker 发现没有应用，就会自动停止。
# nginx 容器启动后，发现自己没有提供服务，就会立即停止就是没有程序了
```

**查看日志**

```shell
docker logs -f -t --tail 10 容器，没有日志

# 自己编写一段 shell 脚本
docker run -d centos /bin/sh -c "while true;do echo demoDocker;sleep 1;done"

# [root@localhost ~]# docker ps
CONTAINER ID   IMAGE     COMMAND                   CREATED         STATUS         PORTS     NAMES
3187ee86b9b7   centos    "/bin/sh -c 'while t…"   5 seconds ago   Up 4 seconds 

# 显示日志
-tf				# 显示日志
--tail number	# 要显示日志条数 一般不跟默认全部显示

docker logs -tf 容器id
```

**查看容器中进程信息**

```shell
# 命令 docker top 容器id
[root@localhost ~]# docker top 5b48dd43d79d
UID                 PID                 PPID                C                   STIME               TTY       
root                1878                1857                0                   23:19               ?         
root                2467                1878                0                   23:28               ?         
```

**查看镜像的元数据**

```shell
# 命令
	docker inspect 容器id

# 测试
[root@localhost ~]# docker inspect 5b48dd43d79d
[
    {
        "Id": "5b48dd43d79da087c5e6d85262fec8dfe210d58af717ca89339454cd18604ab4",
        "Created": "2023-06-04T15:19:39.98832657Z",
        "Path": "/bin/sh",
        "Args": [
            "-c",
            "while true;do echo demoDocker;sleep 1;done"
        ],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 1878,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2023-06-04T15:19:40.532374738Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
        "Image": "sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6",
        "ResolvConfPath": "/var/lib/docker/containers/5b48dd43d79da087c5e6d85262fec8dfe210d58af717ca89339454cd18604ab4/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/5b48dd43d79da087c5e6d85262fec8dfe210d58af717ca89339454cd18604ab4/hostname",
        "HostsPath": "/var/lib/docker/containers/5b48dd43d79da087c5e6d85262fec8dfe210d58af717ca89339454cd18604ab4/hosts",
        "LogPath": "/var/lib/docker/containers/5b48dd43d79da087c5e6d85262fec8dfe210d58af717ca89339454cd18604ab4/5b48dd43d79da087c5e6d85262fec8dfe210d58af717ca89339454cd18604ab4-json.log",
        "Name": "/beautiful_noether",
        "RestartCount": 0,
        "Driver": "overlay2",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "default",
            "PortBindings": {},
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "ConsoleSize": [
                34,
                116
            ],
            "CapAdd": null,
            "CapDrop": null,
            "CgroupnsMode": "host",
            "Dns": [],
            "DnsOptions": [],
            "DnsSearch": [],
            "ExtraHosts": null,
            "GroupAdd": null,
            "IpcMode": "private",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": false,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": [],
            "BlkioDeviceReadBps": [],
            "BlkioDeviceWriteBps": [],
            "BlkioDeviceReadIOps": [],
            "BlkioDeviceWriteIOps": [],
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": [],
            "DeviceCgroupRules": null,
            "DeviceRequests": null,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": false,
            "PidsLimit": null,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/asound",
                "/proc/acpi",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/82d6f4c826abfd9bfc306c6582ed15692c15439cb85bd627e9d50d82e659a2da-init/diff:/var/lib/docker/overlay2/c6e5d51ec2cf5dedff8a489135ae79e15d48139d8b39cc29f7f47ffa3caba305/diff",
                "MergedDir": "/var/lib/docker/overlay2/82d6f4c826abfd9bfc306c6582ed15692c15439cb85bd627e9d50d82e659a2da/merged",
                "UpperDir": "/var/lib/docker/overlay2/82d6f4c826abfd9bfc306c6582ed15692c15439cb85bd627e9d50d82e659a2da/diff",
                "WorkDir": "/var/lib/docker/overlay2/82d6f4c826abfd9bfc306c6582ed15692c15439cb85bd627e9d50d82e659a2da/work"
            },
            "Name": "overlay2"
        },
        "Mounts": [],
        "Config": {
            "Hostname": "5b48dd43d79d",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/sh",
                "-c",
                "while true;do echo demoDocker;sleep 1;done"
            ],
            "Image": "centos",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {
                "org.label-schema.build-date": "20210915",
                "org.label-schema.license": "GPLv2",
                "org.label-schema.name": "CentOS Base Image",
                "org.label-schema.schema-version": "1.0",
                "org.label-schema.vendor": "CentOS"
            }
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "147e716e2a9e8f19ff5ba67fcfca2f16974f97ff3839683fdf8bcf7deea5c61f",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {},
            "SandboxKey": "/var/run/docker/netns/147e716e2a9e",
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "6abae36d0da7637637d3ac0c7b3de63b1edbe06a6ff40204b3415b0ac0359b9b",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "c9804ac830f570e910bfe7461508cec77f2d8f0f4ede92d6592e155b4a9b94b6",
                    "EndpointID": "6abae36d0da7637637d3ac0c7b3de63b1edbe06a6ff40204b3415b0ac0359b9b",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:02",
                    "DriverOpts": null
                }
            }
        }
    }
]

```

**进入当前正在运行的容器**

```shell
# 方式一
# 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置

# 命令
sudo docker exec -it 镜像id bashShell 

# 查看 
[root@localhost ~]# docker ps
CONTAINER ID   IMAGE     COMMAND                   CREATED          STATUS          PORTS     NAMES
f919823cec0e   centos    "/bin/sh -c 'while t…"   29 seconds ago   Up 28 seconds             elastic_moore

# 测试 进入
[root@localhost ~]# docker exec -it f919823cec0e /bin/bash

# 查看 
[root@f919823cec0e /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
[root@f919823cec0e /]# ps -ef
UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 12:01 ?        00:00:00 /bin/sh -c while true;do echo demoDocker;sleep 1;done
root         99      0  0 12:02 pts/0    00:00:00 /bin/bash
root        121      1  0 12:02 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1
root        122     99  0 12:02 pts/0    00:00:00 ps -ef

# 方式二
docker attach 容器id

# docker exec		# 进入容器后开启一个新的终端，可以在里面操作（常用）
# docker attach		# 进入容器正在执行的终端，不会启动新的进程
```

 **从容器内拷贝文件到主机上**

```shell
sudo docker cp 容器id : 容器内路径	 目的的主机

# 查看当前主机目录下
[root@35272279c8ec home]# ls
[root@localhost ~]# docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES
35272279c8ec   centos    "/bin/bash"   12 seconds ago   Up 11 seconds             busy_khorana


# 进入 Docker 容器内部
[root@localhost ~]# docker attach 35272279c8ec
[root@35272279c8ec /]# cd home
[root@35272279c8ec home]# ls

# 在容器内新建一个文件
[root@35272279c8ec home]# touch test.cpp
[root@35272279c8ec home]# ls
test.cpp
[root@35272279c8ec home]# ls 
test.cpp
[root@35272279c8ec home]# exit
exit
[root@localhost ~]# docker ps -a
CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS                     PORTS     NAMES
35272279c8ec   centos    "/bin/bash"   2 minutes ago   Exited (0) 9 seconds ago             busy_khorana

# 将这个文件从容器中拷贝出来
[root@localhost home]# docker cp 35272279c8ec:/home/test.cpp /home
Successfully copied 1.54kB to /home
[root@localhost home]# ls
test.cpp
```

**小结**

```shell
attach		Attach to a running container 							#当前 she17 下 attach 连接指定运行镜像
build		Build an image from a Dockerfile						# 通过 Dockerfile 定制镜像
commit		create a new image from a container changes				#提交当前容器为新的镜像
cp			Copy files/folders from the containers filesystem to the host path#从容器中拷贝指定文件或者目cp录到宿主机中
# 录到宿主机中
create		Create a new container									# 创建一个新的容器，同 run，但不启动容器
diff 		Inspect changes on a container's filesystem				# 查看 docker 容器变化
events 		Get rea1 time events from the server					# 从 docker 服务获取容器实时事件
exec 		Run a command in an existing container					# 在已存在的容器上运行命令
export		Stream the contents of a container as a tar archive 	# 导出容器的内容流作为一个 tar 归档文件[对应import]
history		show the history of an image							# 展示一个镜像形成历史
images		List images												# 列出系统当前镜像
import 		Create a new filesystem image from the contents of a tarball	# 从tar包中的内容创建一个新的文件系统映像[对应export]
# 统映像[对应 export]
info		Display system-wide information							# 显示系统相关信息
inspect		Return Tow-level information on a container				# 查看容器详细信息
Kill a running container											# ki11 指定 docker 容器
load		Load an image from a tar archive						# 从一个 tar 包中加载一个镜像[对应 save]
login		Register or Login to the docker registry server			# 注册或者壹陆一个 docker 源服务器
logout		Log out from a Docker registry server					# 从当前 Docker registry 退出
logs		Fetch the Togs of a container							# 输出当前容器日志信息
port		Lookup the public-facing port which is NAT-ed to PRIVATE_PORT		# 查看映射端口对应的容器内部源端口
pause		Pause al1 processes within a container					# 暂停容器
ps			List containers											# 列出容器列表
pull		Pull an image or a repository from the docker registry server		# 从docker镜像源服务器拉取指定镜像或者库镜像
push		Push an image or a repository to the docker registry server			# 推送指定镜像或者库镜像至docker源服务器
restart		Restart a running container								# 重启运行的容器
rm			Remove one or more contatners							# 移除一个或者多个容器
rmi			Remove one or more images								# 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]
run			Run a command in a new container						# 创建一个新的容器并运行一个命令
save		Save an image to a tar archive							# 保存一个镜像为一个 tar 包[对应 ]oad]
search		Search for an image on the Docker Hub					# 在 docker hub 中搜索镜像
start		Start a stopped containers								# 启动容器
stop		Stop a running containers								# 停止容器
tag			Tag an image into a repository							# 给源中镜像打标签
top			Lookup the running processes of a container				# 查看容器中运行的进程信息
unpause		Unpause a paused container								# 取消暂停容器
version		show the docker version information						# 查看 docker 版本号
wait		Block until a container stops, then print its exit code	# 截取容器停止时的退出状态值
```

## 练习

> Docker 安装 nginx

```shell
# 1、搜索镜像 search
# 2、下载镜像 pull
# 3、运行测试
[root@localhost ~]# docker images
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
nginx        latest    605c77e624dd   17 months ago   141MB
centos       latest    5d0da3dc9764   20 months ago   231MB

# -d  		后台运行
# --name	给容器命名
# -p		宿主机端口，容器内部端口
[root@localhost ~]# docker run -d --name nginx01 -p 3344:80 nginx
a3d61d0c081dcbec582fb5f5c8dfbc59a97271b8b59a51b276ba7a32f680c389
[root@localhost ~]# docker ps
CONTAINER ID   IMAGE     COMMAND                   CREATED         STATUS         PORTS                                   NAMES
a3d61d0c081d   nginx     "/docker-entrypoint.…"   7 seconds ago   Up 6 seconds   0.0.0.0:3344->80/tcp, :::3344->80/tcp   nginx01
[root@localhost ~]# curl localhost:3344

# 进入容器
[root@localhost ~]# docker exec -it nginx01 /bin/bash
root@a3d61d0c081d:/# whereis nginx
nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx
root@a3d61d0c081d:/# cd /etc/nginx/
root@a3d61d0c081d:/etc/nginx# ls
conf.d	fastcgi_params	mime.types  modules  nginx.conf  scgi_params  uwsgi_params
```

> Docker 安装一个 tomcat

```shell
# 下载
docker pull tomcat

# 启动运行
docker run -d -p 3344:8080 --name tomcat01 tomcat

# 创建好了也可以选择启动
[root@localhost ~]# docker start 869ec7fbde3b
869ec7fbde3b

# 进入 tomcat 容器
[root@localhost ~]# docker exec -it tomcat01 /bin/bash
root@869ec7fbde3b:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work

# 发现问题 1、Linux 命令少了。2、没有 webapps。

# 进入容器查看
root@869ec7fbde3b:/usr/local/tomcat# ls 
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work
root@869ec7fbde3b:/usr/local/tomcat# ls -a webapps.dist/
.  ..  ROOT  docs  examples  host-manager  manager

# 拷贝文件内容
root@869ec7fbde3b:/usr/local/tomcat# cp -r webapps.dist/* webapps
root@869ec7fbde3b:/usr/local/tomcat# ls -a webapps
.  ..  ROOT  docs  examples  host-manager  manager

```

> 部署 es + kibana

```shell
# es 暴露的端口很多！
# es 十分的耗内存
# ex 的数据一般需要放置到安全目录！ 挂载
# --net somenetwork ? 网络配置

# 启动 elasticsearch
docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch

# 启动了 linux 就卡住了 docker stats 查看 CPU 的状态
CONTAINER ID   NAME       CPU %     MEM USAGE / LIMIT     MEM %     NET I/O          BLOCK I/O    PIDS
869ec7fbde3b   tomcat01   0.57%     162.7MiB / 3.682GiB   4.32%     10.3kB / 126kB   261MB / 0B   36



# 增加内存的限制，修改配置文件 -e 环境配置修改
docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e  ES_JAVA_OPTS="Xms=64m -Xmx512m" elasticsearch
```

## commit 镜像

```shell
docker commit 提交容器成为一个新的副本

# 密令和git原理类似
docker commit -m="提交的描述信息" -a="作者" 容器id 目标镜像名：[TAG]

# 测试

# 1、启动一个默认的tomcat

# 2、发现这个默认的tomcat是没有webapps应用，镜像的原因，官方的镜像默认 webapps 下面是没有文件的！

# 3、自己拷贝进去基本的文件

# 4、将操作过容器通过commit提交为一个镜像！方便以后就使用修改过后的镜像既可，这就是自己的一个修改。
```

## 容器数据卷

### 什么是容器数据卷

**Docker的理念回顾**

将应用和环打包成一个容器！

数据？如果数据都在容器中，那我们容器删除，数据就会丢失 ==需求：数据可以持久化==

MySQL，容器删了，删库跑路咯！ ==需求：MySQL数据可以存储在本地！==

容器之间可以有一个数据共享的技术！Docker 容器中产生的数据，同步到本地！

这就是数据卷技术！目录的挂载，将我们的容器内的目录，挂载到 Linux 上面！

**总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！**

## 使用数据卷

> 方式一：直接使用命令来挂载 -v

```shell
docker run -it -v  主机目录， 容器内目录 

# 测试
# 挂载并进入
[root@localhost home]# docker run -it -v /home/ceshi:/home centos /bin/bash

# 挂载但不进入
[root@localhost home]# docker run -v /home/ceshi:/home centos /bin/bash

# 启动起来时候就可以通过 Docker inspect 容器id 查看挂载情况
```

![image-20230609074236324](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230609074236324.png)

测试效果

![image-20230609001506846](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230609001506846.png)

再来测试！

1. 停止容器
2. 宿主机上修改文件
3. 启动容器
4. 容器内的数据依旧是同步的！

![image-20230609075502834](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230609075502834.png)

## 实战：安装MySQL

思考：mysql 的数据持久化的问题！

```shell
# 获取镜像
[root@localhost ~]# docker pull mysql

# 运行容器，需要做数据挂载！ 安装启动MySQL，需要配置密码的，这是要注意点！
# 官方测试：docker run -it --name some-mysql -e MYSQL_ROOT_PASSWORD-my-secret-pw -d mysql:tag

#启动我们的
-d	后台运行
-p	端口映射
-v	环境配置
--name	容器名字
[root@localhost ~]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=value123 --name mysql01 mysql

# 进入容器进行测试
```

## 匿名挂载和具名挂载

```shell
# 匿名挂载
-v	容器内路径
docker run -d -P --name nginx01 -v /etc/nginx nginx

#查看所有的volume的情况
[root@localhost data]# docker volume ls
DRIVER    VOLUME NAME
local     c35e1f73e3df01c6762c6f908c367d2ca24d247d47cc93e72467bbff89ad51d5

# 这里发现，这种就是匿名挂载，在 -v 只写了容器内的路径，没有写容器的路径

# 具名挂载
[root@localhost data]# docker run -d -P --name nginx03 -v juming-nginx:/etc/nginx nginx
a1d8c8b514ede41cbc2b011faaf222f0469fb2f36561babd1e7f346ad8859a1b
[root@localhost data]# docker volume ls
DRIVER    VOLUME NAME
local     c35e1f73e3df01c6762c6f908c367d2ca24d247d47cc93e72467bbff89ad51d5
local     juming-nginx

# 通过 -v  卷名：容器内路径
# 查看一下这个卷
```

![image-20230609095332914](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230609095332914.png)

所有的Docker容器的卷，没有指定目录的情况下都是在 ==/ver/lib/docker/volumes/***/_data_==

可以通过具名挂载方便的我们的一个卷，大多数情况再使用的==具名挂载==

```shell
# 如何确定是具名挂载还是匿名挂载，还是指定路径挂载！
-v	容器内路径				# 匿名挂载
-v	卷名：容器内路径			# 具名挂载
-v 	/宿主机路径::容器内路径 		#指定路径挂载
```

拓展：

```shell
# 通过 -v 容器内路径， ro rw 改变读写权限
ro	readonly 		# 只读
rw	readwrite		# 可读可写

# 一旦这个设置了容器权限，容器对我们挂载出来的内容就有限定了!
docker run -d -P --name nginx03 -v juming-nginx:/etc/nginx:ro nginx
docker run -d -P --name nginx03 -v juming-nginx:/etc/nginx:rw nginx

# ro 只要看到 ro 就说明这个路只能通过宿主机来操作，容器内部无法操作！
```

## 初识Dockerfile

Docker 就是用来构建Docker镜像的构建文件！

通过这个脚本生成镜像，镜像是一层一层的，脚本一个个的命令，每个命令都是一层！

```shell
# 创建一个 dockerfile 文件，名字可以随机 建议 dockerfile
# 文件中的内容 指令（大写） 参数

FROM centos

VOLUME ["volume01","volume02"]

CMD echo "------end-----"

CDM /bin/bash

这里的每个命令，就是镜像的一层！
```

![image-20230609104551795](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230609104551795.png)

```shell
# 启动自己写容器
```

![image-20230609105520047](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230609105520047.png)

```shell
# 此时是匿名创建，查看一下卷挂载的路径
```

![image-20230609110402686](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230609110402686.png)

```shell
# 查看数据是否同步成功
```

![image-20230609110813313](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230609110813313.png)

 测试一下刚才的文件是否同步出去了！

这种方式未来使用的十分多，因为通常构建自己的镜像！

假设构建镜像时候没有挂载卷，要手动镜像挂载 -v 卷名容器路径！



## 数据卷容器

**多个 mysql 同步数据**

![image-20230609164701991](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230609164701991.png)

```shell
# 启动 3 个容器，通过刚才写的镜像启动
```

![image-20230609165322862](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230609165322862.png)

```shell
# 与另一个容器镜像关联挂载
# value02 挂上 value01

--name value02  # 容器间的数据共享

# 操作挂载
[root@localhost ~]# docker run  -it --name value02 --volumes-from value01 value/centos:1.0 
```

![image-20230609190546056](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230609190546056.png)

![image-20230609190819639](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230609190819639.png)

```shell
# 即使不小心删除了一个容器其余的容器数据还是存在的！
```

多个mysql实现数据共享

```shell
[root@localhost ~]# docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=value123 --name mysql01 mysql

[root@localhost ~]# docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=value123 --name mysql02 --volumes-from mysqly01 mysql
```

## DockerFile 构建过程

**基础知识：**

1、每个保留关键字（指令）都是必须是大写字母

2、执行从上到下顺序执行

3、# 表示注释

4、每个指令都会创建提交一个新的镜像层，并提交！

5、docker是面向开发的，以后要发布项目，做镜像，就需要编写 dockerfile文件，这个文件十分简单！

6、docker 镜像逐渐成为企业交付的标准，必须掌握！

7、dockerfile：构建文件，定义了一切的步骤，源代码

8、dockerlmages：通过dockerfile构建生成的镜像，最终发布和运行的产品！

9、docker容器：容器就是运行起来提供服务器

## dockerfile 的指令

```shell
FROM				# 基础镜像，一切从这里开始构建
MAINTATNER			# 镜像是谁写的，姓名+邮箱
RUN					# 镜像构建的时候需要运行的命令
ADD					# 步骤，tomcat镜像，这个tomcat压缩包！ 添加内容
WORKDIR				# 镜像的工作目录
VOLUME				# 挂载的目录
EXPOSE				# 保留端口配置
CMD					# 指定这个容器启动的时候需要运行的命令，只有最后一个会生效，可被替代
ENTRYPOINT			# 指定这个容器启动的时候运行的命令，可以追加命令
ONBUILD				# 当构建一个被继承 dockerfile 这个时候就会运行 ONBUTLD 的指令。触发指令。
COPY				# 类似 ADD ，将我们的文件拷贝到镜像中
ENV					# 构建的时候设置环境变量！
```

## 实战测试

```shell
# 1、编写 dockerfile 的文件
[root@localhost dockerfile]# vim mydockerfile
[root@localhost dockerfile]# cat mydockerfile 
FROM centos

MAINTAINER value123<12345@qq.com>

ENV MYPATH /usr/local

WORKDIR $MYPATH

RUN yum -y install vim
RUN yum -y install net-tools

EXPOSE 80

CMD ehco $MYPATH
CMD echo "-----end-----"
CMD /bin/bash

# 2、通过这个文件构建镜像
# 命令 docker build -f dockerfile文件路径 -t 镜像名:[tag]

# 3、测试运行

# 4、查看构建信息
[root@localhost ~]# docker history 容器id
```

> CMD 和  ENTRYPOINT 区别

```shell
CMD					# 指定这个容器启动的时候需要运行的命令，只有最后一个会生效，可被替代
ENTRYPOINT			# 指定这个容器启动的时候运行的命令，可以追加命令
```

测试 cmd

```shell
# 编写 dockerfile 文件
[root@localhost dockerfile]# vim mydockerfile01
[root@localhost dockerfile]# cat mydockerfile01 
FROM centos
CMD ["ls","-a"]


# 构建镜像
[root@localhost dockerfile]# docker build -f mydockerfile01 -t cmdtest .
[+] Building 0.1s (5/5) FINISHED                                                                             
 => [internal] load build definition from mydockerfile01                                                0.0s
 => => transferring dockerfile: 128B                                                                    0.0s
 => [internal] load .dockerignore                                                                       0.0s
 => => transferring context: 2B                                                                         0.0s
 => [internal] load metadata for docker.io/library/centos:latest                                        0.0s
 => CACHED [1/1] FROM docker.io/library/centos                                                          0.0s
 => exporting to image                                                                                  0.0s
 => => exporting layers                                                                                 0.0s
 => => writing image sha256:7d202bdf002be182b794b7f2b4c90c4fe3560c3ac4f8cebc27f1c8a94ab10a9a            0.0s
 => => naming to docker.io/library/cmdtest 
 
 # run 运行，发下 ls -a 已生效
 [root@localhost dockerfile]# docker run -it cmdtest
.   .dockerenv	dev  home  lib64       media  opt   root  sbin	sys  usr
..  bin		etc  lib   lost+found  mnt    proc  run   srv	tmp  var


# 想追加一个命令 -l ls -al
[root@localhost dockerfile]# docker run -it cmdtest -l
docker: Error response from daemon: failed to create task for container: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: "-l": executable file not found in $PATH: unknown.

# cmd 的清理下 -l 替换了 CMD ["ls","-a"] 命令， -l 不是命令所以报错
```

测试 ENTRYPOINT

```shell
# 编辑文件
[root@localhost dockerfile]# vim dockerfile-cmd-entyrpoint
[root@localhost dockerfile]# cat dockerfile-cmd-entyrpoint 
FROM centos
ENTRYPOINT ["ls","-a"]

# 构建镜像
[root@localhost dockerfile]# docker build -f dockerfile-cmd-entyrpoint -t entorypoint .
[+] Building 0.1s (5/5) FINISHED                                                                             
 => [internal] load .dockerignore                                                                       0.0s
 => => transferring context: 2B                                                                         0.0s
 => [internal] load build definition from dockerfile-cmd-entyrpoint                                     0.0s
 => => transferring dockerfile: 146B                                                                    0.0s
 => [internal] load metadata for docker.io/library/centos:latest                                        0.0s
 => CACHED [1/1] FROM docker.io/library/centos                                                          0.0s
 => exporting to image                                                                                  0.0s
 => => exporting layers                                                                                 0.0s
 => => writing image sha256:b325f5b972337e763ad3b2c0f1a720eb2d5b11a39b3d88008cc5a0e42393b617            0.0s
 => => naming to docker.io/library/entorypoint 
 
  # run 运行，发下 ls -a 已生效
  [root@localhost dockerfile]# docker run -it entorypoint
.   .dockerenv	dev  home  lib64       media  opt   root  sbin	sys  usr
..  bin		etc  lib   lost+found  mnt    proc  run   srv	tmp  var

# 想追加一个命令 -l ls -al
[root@localhost dockerfile]# docker run -it entorypoint -l
total 0
drwxr-xr-x.   1 root root   6 Jun  9 14:54 .
drwxr-xr-x.   1 root root   6 Jun  9 14:54 ..
-rwxr-xr-x.   1 root root   0 Jun  9 14:54 .dockerenv
lrwxrwxrwx.   1 root root   7 Nov  3  2020 bin -> usr/bin

# 替换成功
```

## 实战：Tomcat 镜像

1、准备镜像文件 tomcat 压缩包，jdk 的压缩包

![image-20230610142125687](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230610142125687.png)

2、编写 dockerfile 文件 `Dockerfile`，build 会自动寻找这个文件，就不需要 -f 指定了！

```shell
FROM centos
MAINTAINER value123<1234@qq.com>

COPY ceshi /usr/local/ceshi

ADD jdk-20_linux-x64_bin.tar.gz /usr/local
ADD apache-tomcat-9.0.76.tar.gz /usr/local

# RUN yum -y install vim

ENV MYPATH /usr/local
WORKDIR $MYPATH

ENV JAVA_HOME /usr/local/jdk-20.0.1
ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.76
ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.76

ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin

EXPOSE 8080

CMD /usr/local/apache-tomcat-9.0.76/bin/startup.sh && tail -F /usr/local/apache-tomcat-9.0.76/bin/logs/catalina.out
```

3、构建镜像

```shell
[root@localhost home]# docker build -t diytomcat .
[+] Building 2.1s (10/10) FINISHED                                                                               
 => [internal] load build definition from Dockerfile                                                             
 => => transferring dockerfile: 1.46kB                                                                           
 => [internal] load .dockerignore                                                                               
 => => transferring context: 2B                                                                                 
 => [internal] load metadata for docker.io/library/centos:latest                                                 
 => [1/5] FROM docker.io/library/centos                                                                         
 => [internal] load build context                                                                               
 => => transferring context: 11.68MB                                                                             
 => CACHED [2/5] COPY ceshi /usr/local/ceshi                                                                     
 => CACHED [3/5] ADD jdk-20_linux-x64_bin.tar.gz /usr/local                                                     
 => [4/5] ADD apache-tomcat-9.0.76.tar.gz /usr/local                                                             
 => [5/5] WORKDIR /usr/local                                                                                     
 => exporting to image                                                                                           
 => => exporting layers                                                                                         
 => => writing image sha256:0c7027963e8858d35d11f6f78b1eee1333c221df7bbe126cbe425d6d42b867a9                     
 => => naming to docker.io/library/diytomcat  
```

4、进入个人新创建的容器

```shell
docker run -d -p 3344:8080 --name valuetomcat -v /home/value123/build/tomcat:/url/local/apache-tomcat-9.0.76/webapps -v /home/value123/build/tomcat/tomcatlogs:/url/local/apache-tomcat-9.0.76/logs diytomcat

# 进入官方
docker run -p 3344:8080 --name valuetomcat -v /home/value123/build/tomcat:/usr/local/tomcat/webapps tomcat


/usr/local/tomcat/webapps

 docker run -v /home/value123/build/tomcat/test:/url/local/apache-tomcat-9.0.76/webapps/test diytomcat /bin/bash
 docker run -v /home/value123/build/tomcat/tomcatlogs:/url/local/apache-tomcat-9.0.76/logs /bin/bash

# 创建成功
[root@localhost home]# docker run -d -p 3344:8080 --name valuetomcat -v /home/value123/build/tomcat/test:/url/local/apache-tomcat-9.0.76/webapps/test -v /home/value123/build/tomcat/tomcatlogs:/url/local/apache-tomcat-9.0.76/logs diytomcat
1f2f99c40fb6374a5a3a1c4a57ea25a909fc70e85cdcea6bdae46b6439ed21fa

```

5、访问测试

6、发布项目（由于做了卷挂载，可以直接在本地编写项目就可以发布了！）

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/j2ee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee
         http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
         version="2.4">
 
</web-app>
```

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>hallo value</title>
</head>
<body>
Hello World!<br/>
<%
out.println("你的 IP 地址 " + request.getRemoteAddr());
%>
</body>
</html>
```







## 发布自己的镜像

> DockerHub

1、地址 https://hub.docker.com/ 注册自己的账号

2、确定这个账号可以登录

3、在服务器上提交自己的镜像

```shell
[root@localhost ~]# docker login --help

Usage:  docker login [OPTIONS] [SERVER]

Log in to a registry.
If no server is specified, the default is defined by the daemon.

Options:
  -p, --password string   Password
      --password-stdin    Take the password from stdin
  -u, --username string   Username

```

4、登录完毕后既可以提交镜像了，就是一步 docker push

## Docker 网络

```shell
# 查看容器的内部网络地址 	ip addr,	发现容器起送的时候会得到一个  eth0@if15  Ip 地址 docker 分配的
[root@localhost ~]# docker exec -it tomcat01 ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
14: eth0@if15: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever

# Linux能不能ping通容器内部
[root@localhost ~]# ping 172.17.0.2
PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.238 ms
64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.090 ms
64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.100 ms
^C
--- 172.17.0.2 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2001ms
rtt min/avg/max/mdev = 0.090/0.142/0.238/0.068 ms

# Linux 可以ping 通 docker 容器内部‘
```

> 原理

1、没启动一个docker容器，docker就会给docker容器分配一个 ip ，只需要安装了docker 就会自动分配。

使用的技术是 evth-pair 技术！

再次测试 ip addr

![image-20230611142552458](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230611142552458.png)

2、在启动一个容器测试，发现又多了一对网卡

![image-20230611142817093](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230611142817093.png)

```shell
# 发现这个容器带来网卡，都是一对对的
# veth-pair 就是一对的虚拟设备接口，都是成对出现的，一段连着协议，一段彼此相连
```

3、绘制一个网咯模型图

![image-20230611144322525](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230611144322525.png)

**结论：tocat01 和 tomcat02 是公用的一个路由器，docker0。**

所有的容器不指定网络的情况下，都是 docker0 路由的，docker会给每个容器分配一个默认的可用 ip

> 小结

Docker 使用的是 Linux 的桥接

![image-20230611152700140](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230611152700140.png)

docker 中所有的网路接口都是虚拟的。虚拟的转发效率高！（内网传递文件！）

只要容器删除，对应网桥一对就没了！



## --link

> 思考一个场景，编写了一个微服务，database URL=ip：，项目不重启，数据库 ip 换掉了，希望可以出来这个问题，可以用来名字来访问容器？

```shell
[root@localhost ~]# docker exec -it tomcat01 ping tomcat02
OCI runtime exec failed: exec failed: unable to start container process: exec: "ping": executable file not found in $PATH: unknown

# 如何解决呢？
# 通过 --link 既可以解决网网络的连通问题
[root@localhost ~]# docker run -d  --name tomcat03 --link tomcat02 tomcat
50f3b33cf9249199f6b8ca6653153d22396643a21265b32de333a61fec3e1659

# 使用 network 网卡中各个容器的ip
[root@localhost ~]# docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
925384e1f423   bridge    bridge    local
d234945f7de0   host      host      local
417f65e8e673   none      null      local
[root@localhost ~]# docker network inspect 925384e1f423
```

![image-20230611160246898](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230611160246898.png)

```shell
# 查看 hosts 配置，在这里发现！
[root@localhost ~]# docker exec -it tomcat03 cat /etc/hosts
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
172.17.0.3	tomcat02 54c42ae89431
172.17.0.4	50f3b33cf924

```

本质探究：--link 就是在 hosts 配置中增加了一个  172.18.0.3 tomcat02 

但是不建议使用 --link 了！

## 自定义网络

> 查看所有的 docker 网络

![image-20230611161640801](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230611161640801.png)

### 网络模式

bridge： 桥接 docker （默认）

none：不配置网络

host：和宿主机共享网络

container：容器网络连通！（用的很少！局限很大）

**测试**

```shell
# 直接启动命令 --net bridge ，而这个就是 docker0
docker run -d -p -name tomat01 tomacat
docker run -d -p -name tomat01 tomacat --net bridge tomcat

# docker0 特点，默认，域名不能访问， --link 可以打通连接！

# 可以自定义一个网络！
# --driver
# --subnet 192.168.0.0/16
# --gateway 192.168.0.1

[root@localhost ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet
7deb8c8295ec6417048b057d41f5ccdcde9aca2b55d28727dce048f720eb5012

[root@localhost ~]# docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
925384e1f423   bridge    bridge    local
d234945f7de0   host      host      local
7deb8c8295ec   mynet     bridge    local
417f65e8e673   none      null      local

```

查看我们自己的网络

![image-20230611163251080](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230611163251080.png)

```shell
[root@localhost ~]# docker run -d --name tomcat-net-01 --net mynet tomcat
b0dc8eb49a5eab7c535889c98a4a9113f7a20a4243915361537c9951be4439b0
[root@localhost ~]# docker run -d --name tomcat-net-02 --net mynet tomcat
daca40ac868e2cdb06a13abbe3966348054b317192c66509e4d20a0cf8a72d37
[root@localhost ~]# docker network inspect mynet
[
    {
        "Name": "mynet",
        "Id": "7deb8c8295ec6417048b057d41f5ccdcde9aca2b55d28727dce048f720eb5012",
        "Created": "2023-06-11T16:29:10.729140299+08:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "192.168.0.0/16",
                    "Gateway": "192.168.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "b0dc8eb49a5eab7c535889c98a4a9113f7a20a4243915361537c9951be4439b0": {
                "Name": "tomcat-net-01",
                "EndpointID": "64653e018d9da06dd2881e2482493bc7b77d6d6ab91613fa9bcc8756d55929e9",
                "MacAddress": "02:42:c0:a8:00:02",
                "IPv4Address": "192.168.0.2/16",
                "IPv6Address": ""
            },
            "daca40ac868e2cdb06a13abbe3966348054b317192c66509e4d20a0cf8a72d37": {
                "Name": "tomcat-net-02",
                "EndpointID": "7d9241565a533fd1855eb6db7fa386d2da5b6be3ce90a342b641e4e3fe58d8ee",
                "MacAddress": "02:42:c0:a8:00:03",
                "IPv4Address": "192.168.0.3/16",
                "IPv6Address": ""
            }
        },
        "Options": {},
        "Labels": {}
    }
]


# 再次测试 ping 连接
[root@localhost ~]# docker exec -it tomcat-net-01 ping 192.168.0.3

# 再次使用 名字 ping 连接
[root@localhost ~]# docker exec -it tomcat-net-01 ping tomcat-net-02
```

自定义的网络 docker 都已经帮助维护了对应的关系，推荐使用。

好处：

redis：不同的集群使用不同的网络，保证集群是安全和健康的。

mysql：不同的集群使用不同的网络，保证集群是安全和健康的。

## 网络连通

![image-20230611164829361](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230611164829361.png)

![image-20230611164912147](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230611164912147.png)

```shell
# 测试打通 tomcat01 - mynet

# 连通之后就是奖 tomcat01 放到了 mynet 网络下

# 一个容器两个 ip 地址
```

![image-20230611165413371](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230611165413371.png)

```shell
# 测试 ping 通
[root@localhost ~]# docker exec -it tomcat01 ping tomcat-net-01
```

**结论：假设要跨网络操作别人，就需要使用 docker network connect 连通！**

## 实战：部署Redis集群

![image-20230611173649357](C:\Users\Value.DESKTOP-F8NSHR6\AppData\Roaming\Typora\typora-user-images\image-20230611173649357.png)









