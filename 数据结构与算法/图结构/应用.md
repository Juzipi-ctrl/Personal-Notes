## 图应用

前面我们介绍了图的相关性质，以及图的遍历方式，这一部分我们接着来看图的相关应用。

### 生成树和最小生成树

在开始讲解最小生成树之前，我们先来回顾一下之前讲解的连通分量。

- 对于无向图来说，如果图中任意两点都是连通的，那么我们就称这个图为**连通图**。
- 对于有向图来说，如果图中任意顶点A和B，既有从A到B的路径，也有B到A的路径，则称该有向图是**强连通图**。

而连通分量则要求是某个图的子图（子图可以是只包原图含部分顶点和边的图，也可以就是原图本身，因为定义只是子集，不是真子集），并且子图也要是连通的才可以，还有一个重要条件是必须拥有极大顶点数（能够保证图连通的且包含原图最大的顶点数）并且包含所有依附于这些顶点的边（这个极大更偏向于顶点数的极大），我们就称这个子图为极大连通子图。

- 无向图的极大连通子图称为连通分量。
- 有向图的极大强连通子图称为强连通分量。

比如下面的有向图，这个图本身并不是连通的：

![image-20220903101036333](https://image.itbaima.cn/markdown/2022/09/03/lHEi8GWsIjCFg3D.png)

其中图1和图2都满足上述条件，都是强连通分量，本身就是连通并且已经到达最大的顶点数和边数了（只要再加入其他的顶点和边就会导致不连通）但是图3并不是子图（A到B的边缺失）并且不是强连通的，所以说不是强连通分量。

又比如下面这个无向图，这个图本身也是不连通的：

![image-20220822214010526](https://image.itbaima.cn/markdown/2022/08/22/jlUfrcTXNPYGvOR.png)

其中图1和图3都满足条件，都是连通分量，但是图2并没有到达最大的顶点数和边数，所以说不是连通分量。

当然上面都是原图不连通的情况，如果原图就是一个连通图，包含其所有顶点和边的子图就已经满足条件了，所以其本身就是一个连通分量；同样的，如果原图就是一个强连通图，那么其本身就是一个强连通分量。

总结如下：

- 如果原图本身不连通，那么其连通分量（强连通分量）不止一个。
- 如果原图本身连通，那么其连通分量（强连通分量）就是其本身。

极大连通子图我们回顾完了，那么我们接着来讨论一下**极小连通子图**。这里的极小主要是说的边数的极小，首先依然要是原图的子图并且是连通的，但是此时要求具有最大的顶点数和最小的边数，也就是说再去掉任意一条边会导致图不连通（直接理解为极大连通子图尽可能去掉能去掉的边就行了）

针对于极小连通子图，我们一般只讨论无向图（对于有向图，不存在极小强连通子图的说法，因为主要是讨论生成树）我们依然将原图就是连通图和原图不是连通图分开分析，首先是原图本身就是连通图的情况：

![image-20220901180909877](https://image.itbaima.cn/markdown/2022/09/01/zCap6w2A51rEnkK.png)

原图本身就是连通图，那么其极大连通子图就是其本身，此时我们需要尽可能去掉那些“不必要”的边，依然能够保证其是连通的，也就是极小连通子图。可以看到右边两幅图，跟左边这幅图包含了同样的顶点数量，但是边数被去掉了一些，并且如果再继续去掉任意一条边的话，那么就会导致不连通，所以说左边两幅图都是右边这幅图的极小连通图（当然，就像上面这样，可能会出现多种方案，极小连通图不唯一）

我们发现，无论是去掉哪些边的情况，到最后一定是只留下 N-1 条边（其中N是顶点数）每个顶点有且仅有一条路径相连，也就是包含原图全部N个顶点的极小连通子图，我们一般称其为：**生成树**，为什么叫生成树呢，因为结点数和边数正好满足树的定义（且不存在回路的情况），我们可以将其调整为一棵树：

![image-20220903103444346](https://image.itbaima.cn/markdown/2022/09/03/ldtA9jbE1JXMcWf.png)

当然，这是原图本身就连通的情况，如果原图本身不连通的话，那么就会出现多个连通分量，此时就会得到一片**生成森林**，森林中的树的数量就是其连通分量的数量。

那么我们在程序中要怎么才能得到一个有向图的生成树呢？我们可以使用前面讲解的两种图的遍历方式来进行生成，我们以下图为例，这是一个普通的无向连通图：

![image-20220903111255127](https://image.itbaima.cn/markdown/2022/09/03/RI5Lrpt8WeOkdZX.png)

我们如果按照深度优先遍历的方式，从G开始，那么就会得到下面的顺序：

![image-20220903112122707](https://image.itbaima.cn/markdown/2022/09/03/CrsQhon4wxOAjRm.png)

按照顺序我们就可以得到一棵生成树：

![image-20220903112332571](https://image.itbaima.cn/markdown/2022/09/03/k1IctqPrOA6BKgp.png)

虽然看着很奇怪，但是按照我们的顺序，得到的树就是这样的，可以发现，因为我们的深度优先搜索不会去走那些回头路，相当于直接把哪些导致回路和多余的边给去掉了，最后遍历得到的结果就是一颗生成树了。

同样的，我们来看看如果是按照广度优先遍历的方式，又会得到什么结果呢？

![image-20220903112733812](https://image.itbaima.cn/markdown/2022/09/03/UhRBnocjCL3uD9E.png)

最后得到的生成树为：

![image-20220903113108162](https://image.itbaima.cn/markdown/2022/09/03/FKRSnvProHtXegi.png)

实际上我们发现，在广度优先遍历下得到的生成树，也是按照每一层在进行排列的，非常清晰。当然，因为深度优先遍历和广度优先遍历本身的顺序就不是唯一的，所以最后得到的生成树也不是唯一的。

生成树讨论完成之后，我们接着来讨论一下最小生成树，那么这个最小指的是什么最小呢？如果我们给一个无向图的边都加上权值（网图）现在要求生成树边的权值总和最小，我们就称这棵树为**最小生成树**（注意最小生成树不唯一，因为有可能出现多种方案都是最小的情况）比如下面的就是最后得到的最小生成树了：

![image-20220903113954010](https://image.itbaima.cn/markdown/2022/09/03/BWEzS1YOwDohRdU.png)

构建最小生成树有两种算法，一种是**普利姆（Prim）**算法，还有一种是**克鲁斯卡尔（Kruskal）**算法，我们先来讨论第一种：

我们以下图为例：

![image-20220903142138573](https://image.itbaima.cn/markdown/2022/09/03/c4Xge3QImBdDKYt.png)

普利姆算法的核心就是从任意一个顶点开始，不断成长为一棵树，每次都会选择尽可能小的方向去进行延伸，比如我们一开始还是从顶点A开始：

此时与A相连的边有B和E，A的延伸方向有两个，此时我们只需要选择一个最小的就可以了：

![image-20220903142208537](https://image.itbaima.cn/markdown/2022/09/03/LZ5ho6mxtweRPMg.png)

此时我们已经构建出了由A、E组成的一棵树，同样的，我们需要去寻找与当前树中A、E顶点相连的所有顶点，包括B、G、H，哪一个最小，那么下一个延伸的就是哪一个，此时发现H和E之间最小，继续延伸：

![image-20220903142245688](https://image.itbaima.cn/markdown/2022/09/03/zT75jqNVS4RX3bI.png)

现在已经变成了由A、E、H组成的一棵树，同样的，按照之前的思路继续寻找一个最小的方向进行延伸：

![image-20220903142413604](https://image.itbaima.cn/markdown/2022/09/03/nJWbov1LZNBR8lX.png)

继续进行延伸，发现F、K之间最小：

![image-20220903142558882](https://image.itbaima.cn/markdown/2022/09/03/OyGRMXi9K5fE3zD.png)

此时K、B和K、D和K、H的权重都是4，其中H顶点已经走过了，不能出现回路，所以说不考虑，此时随便选择K、B或是K、D都可以，不会影响后续结果：

![image-20220903142829606](https://image.itbaima.cn/markdown/2022/09/03/uxI21o4vnbdNLkB.png)

此时依然是K、D为最小，所以说直接选择：

![image-20220903142917096](https://image.itbaima.cn/markdown/2022/09/03/cR2BPhbI5X9jAU3.png)

紧接着，我们发现最小权重的来到了5，此时权重为5的边有B、E和H、I和B、D，但是由于E、D已经走过，此时直接选择H、I即可：

![image-20220903143057702](https://image.itbaima.cn/markdown/2022/09/03/Lg5Tf1Y2AQ9hjNk.png)

接着，我们发现I、G也是5，直接选择即可：

![image-20220903143509563](https://image.itbaima.cn/markdown/2022/09/03/sgfxIojGRUYdQHc.png)

然后最小权重此时就是6了，选择H、J和I、J都可以，随便选择一个即可：

![image-20220903143532060](https://image.itbaima.cn/markdown/2022/09/03/T6BoY4IXa3fKpir.png)

此时，整个图的所有顶点就遍历完成了，现在我们去掉那些没用被采用的边，得到的结果就是我们的最小生成树了：

![image-20220903143645249](https://image.itbaima.cn/markdown/2022/09/03/eVyJ6o8xraRvl3d.png)

虽然样子有点丑，但是把它捋一捋就好了。可以看到省去的边都是尽可能大的边，或是那种导致回路的边，留下的边基本都是权重小的边，得到的就是最小生成树了（注意考试的时候只要按照我们的思路推是肯定没问题的，但是千万要仔细看，不要把边给看漏了，不然会出大问题）

我们接着来看另一种，克鲁斯卡尔算法，它的核心思想就是我们主动去选择那些小的边，而不是像上面一样被动地扩展延伸。

在一开始的时候，直接去掉所有的边，我们从这些边中一个一个选择出来（注意是任意一条边都可以选择，并不是只有选择的顶点旁边才能选择，这个过程中可能会出现多棵树，但是最后一定会连成一棵树的），最后形成一颗最小生成树，假设一开始什么都没选择，被选中的边我们一会用橙色标注：

![image-20220903144403449](https://image.itbaima.cn/markdown/2022/09/03/qdNyC6We2cZHTog.png)

首先我们直接找到最小边，K、F，它的权值为2，所以说直接选择就行：

![image-20220903144533239](https://image.itbaima.cn/markdown/2022/09/03/tTq2NnfJPcvogFG.png)

紧接着就是F、H的边，权重为3，目前最小的了：

![image-20220903144828106](https://image.itbaima.cn/markdown/2022/09/03/MtJxvkjZoScT2KH.png)

此时最小的权重就只有4了，目前有4条边都可以进行选择，但是K、H这条边因为K和H都已经在树中了，所以说不能考虑，其他三条边都是没问题的，我们随便选择一条就行了：

![image-20220903145239074](https://image.itbaima.cn/markdown/2022/09/03/9vEVncqotmeklr7.png)

继续选择权重为4的边：

![image-20220903145321395](https://image.itbaima.cn/markdown/2022/09/03/BXZjrOTYfow51iD.png)

此时权重就来到了5，那么权重为5的顶点我们也可以随便选择一条，只要不会导致出现回路就行了：

![image-20220903145431925](https://image.itbaima.cn/markdown/2022/09/03/qUd8hiGnYyAZLo5.png)

此时连接G、I，我们发现出现了两棵树，没关系的，最后会连成一棵树的，我们继续选择其他权重为5的边：

![image-20220903145551091](https://image.itbaima.cn/markdown/2022/09/03/hpcVj8HwRJnvaf9.png)

此时我们选择A、E这条边，然后是H、I这条边，虽然这条边上的H和I顶点都已经在树中了，但是它们并不属于同一棵树，这种情况也是可以连接的，然后我们继续选择权重为6的顶点：

![image-20220903145828812](https://image.itbaima.cn/markdown/2022/09/03/Sltei9m4GdHXQkW.png)

此时选择I、J或是H、J都可以（最小生成树不唯一）现在我们已经连接上所有的顶点了，最小生成树构建完成，我们把那些没有选择都边都扔了：

![image-20220903143645249](https://image.itbaima.cn/markdown/2022/09/03/eVyJ6o8xraRvl3d.png)

其实无论是哪种算法，最后都能够得到一棵最小生成树，有关实现代码，由于太过复杂，这里就不进行编写了。

### 最短路径问题

前面我们介绍了最小生成树，通过两种算法就能够从众多的边中选择那些尽可能小的边得到一个权重最小的树，这一块我们将继续讨论最小开销相关的问题。

![image-20220903150609366](https://image.itbaima.cn/markdown/2022/09/03/FuxnpoTNezYP9Aa.png)

地铁线路错综复杂，我们想要从一个站点坐到另一个站点，其实是有很多种方案的，比如我们可以选择少的换乘数放的方案，或是距离近的方案，不同的方案可能坐的站点数就不同，而最后我们出站时，始终是按照从A地点到B地点最小经过的站点数进行收费的（比如从A到B有两种方案，前者要坐11个站，后者要坐7个站，但是最后只会按7个站进行收费），那么这么多线路，我们要如何计算得到一条最短的路径呢？

我们首先从最简单的**单源最短路径**进行讨论，所谓单源最短路径，就是一个顶点出发，到其他顶点的最短路径，比如下面的这张图：

![image-20220903153802247](https://image.itbaima.cn/markdown/2022/09/03/6ABvydlgPUqEYIZ.png)

要解决这种问题，我们可以采用**迪杰斯特拉（Dijkstra）**算法，下面我们来看看迪杰斯特拉算法是如何让计算机来计算最短路径的，它跟普利姆算法求最小生成树有着很多相似之处，我们就从A出发，这里我们需要一个表来记录：

![image-20220903195351496](https://image.itbaima.cn/markdown/2022/09/03/cU2s1vRGq9SJkpE.png)

dist这一行记录A到其他顶点的最短路径，path这一行记录的是最短路径所邻接的顶点，我们首先还是从A开始，与A直接相邻的两个分别是B和D，其中B的距离是2，D的距离是5，那么我们就先进行一下记录：

![image-20220903195723929](https://image.itbaima.cn/markdown/2022/09/03/fxAocwRZFzSYgBb.png)

因为都是从A过来的，所以说直接记录为A即可，接着我们继续找到当前A路径最短的一个顶点B，此时顶点B可以到达C、D、A，因为不能走回头路，不考虑A，那么目前从A到达C的最短距离就是经过B到达的，相当于A->B加上B->C的距离：

![image-20220903230103368](https://image.itbaima.cn/markdown/2022/09/03/nbhD6gKrcWHZYwF.png)

然后我们来看顶点D，此时我们发现，除了A直接到D之外，从B也可以到达D，那么我们就可以比较一下，看是从B到D更短一些，还是从A直接到D更短一些 min(2+2,5)min(2 + 2, 5)min(2+2,5) ，通过比较，我们发现从B绕过去会更短一些，只需要4即可，所以说我们将其更新一下：

![image-20220903230254335](https://image.itbaima.cn/markdown/2022/09/03/wZtX2eCvWciJ7mo.png)

接着我们继续找到下一个离A最近的顶点D，D与顶点E和J相连，直接更新即可，比如E的最短路径就是相当于是A到D的最短路径加上D到E的路径，D到J也是同理：

![image-20220903230521739](https://image.itbaima.cn/markdown/2022/09/03/RndcpoWkY6Oe84y.png)

此时继续找到表中下一个距离A最近的顶点J，J可以到达H或者是E，按照同样的方式，我们看看是从D直接到E更短，还是从J到E更短，进行比较 min(6+3,8)min(6 + 3, 8)min(6+3,8) ，得到结果是D直接过去更短，所以说不需要更新。然后H更新为J过去的最短路径：

![image-20220903231152767](https://image.itbaima.cn/markdown/2022/09/03/d8qoaxZiymTGBlv.png)

我们接着来看下一个距离A最近的顶点C，此时C可以到达F和E，我们先来看E，还是对其进行比较，如果从C到达E更短，那么就更新为新的值，min(7+4,8)min(7 + 4, 8)min(7+4,8)，最后仍然是从D到E最短，所以说不变，接着我们把F的值更新一下：

![image-20220903231449081](https://image.itbaima.cn/markdown/2022/09/03/uknUSC2gK5adZjL.png)

然后我们来看下一个距离A最近的顶点E，E连接的就比较多了，此时E最短路径是从D过来的，那么我们就不考虑D，我们来依次看看与其相连的C、F、G、H、J（注意这里比较的是从E到这些顶点，之前比较的是从这些顶点到E，不要以为是一样的了）

- 从E到达顶点C：min(8+4,7)min(8 + 4, 7)min(8+4,7)，故C继续采用原方案。
- 从E到达顶点F：min(8+2,15)min(8 + 2, 15)min(8+2,15)，此时从E到达F路径更短，更新F。
- 从E到达顶点G：直接更新。
- 从E到达顶点H：min(8+6,13)min(8 + 6, 13)min(8+6,13)，故H继续采用原方案。
- 从E到达顶点J：min(8+3,6)min(8 + 3, 6)min(8+3,6)，故J继续采用原方案。

最后得到：

![image-20220903232316607](https://image.itbaima.cn/markdown/2022/09/03/Ek7nhJuXtKSZgeo.png)

我们继续来到下一个离A最近的顶点F，F连接了G和E，但是由于当前最短路径是从E过来的，不能走回头路，所以说直接去看G，比较 min(10+5,17)min(10 + 5, 17)min(10+5,17)，得到从F到达G会更短，所以说更新G：

![image-20220903232542904](https://image.itbaima.cn/markdown/2022/09/03/mphBFRsLArDQHwK.png)

然后我们接着看到下一个最短的顶点H，此时H与G和I相连，我们先来看G，min(13+3,15)min(13 + 3, 15)min(13+3,15)，维持原方案。然后是I，直接更新即可：

![image-20220903232752582](https://image.itbaima.cn/markdown/2022/09/03/PlHs4NE8JTiFZad.png)

虽然此时表已经填完了，但是我们还没有把所有的顶点都遍历完，有可能还会存在更短的路径，所以说别着急，我们还得继续看。此时继续选择下一个离A最近的顶点G，它与E、F、H、I相连，由于其实从F过来的，排除掉F，我们来看看其他三个：

- 从G到达顶点E：min(15+9,8)min(15 + 9, 8)min(15+9,8)，显然选择原方案就行。
- 从G到达顶点H：min(15+3,13)min(15 + 3, 13)min(15+3,13)，依然是选择原方案更短。
- 从G到达顶点I：min(15+4,21)min(15 + 4, 21)min(15+4,21)，从G到达I更短，更新。

最后得到：

![image-20220903233144469](https://image.itbaima.cn/markdown/2022/09/03/RL9XeTnAJBdUNMF.png)

此时我们来看最后一个顶点I，与其连接的有G和H，因为是从G过来的，直接比较H就行了，min(19+8,13)min(19 + 8, 13)min(19+8,13)，维持原方案就行，至此，迪杰斯特拉算法结束。最后得到的表，就是最终的A到达各个顶点的最短路径值了，并且根据path这一栏的数据，我们就可以直接推出一条路径出来。

当然，这只是解决了**单源最短路径**问题，现在我们将问题的难度提升一下，比如我们现在想要求得图中每一对顶点之间的最短路径，那么该如何进行计算呢？最简单的办法就是，我们可以将所有的顶点都执行一次迪杰斯特拉算法，这样我们就可以求到所有顶点之间的最短距离了。只不过这种方式并不是最好的选择，对于这种问题，我们可以选择**弗洛伊德**（Floyd）算法。

比如下面的有向网图（权值别出现负数了，不然要出大问题）：

![image-20220904094948962](https://image.itbaima.cn/markdown/2022/09/04/MdPc7Ew96Ukzxjt.png)

我们可以很轻松地得到它的邻接矩阵：

![image-20220904101234641](https://image.itbaima.cn/markdown/2022/09/04/ZQ7KvWeuJ6bdThx.png)

而弗洛伊德算法则是根据最初的邻接矩阵进行推导得出的。规则如下：

- 从1开始，一直到n（n就是顶点数）的一个矩阵序列A1、A2、...An，我们需要从最初的邻接矩阵开始，从A1开始不断往后推。
- 每一轮，我们都会去更新那些非对角线（对角线都是0，更新了还是0，所以说没必要看）、`i`行`i`列以外的元素，判断水平和垂直方向投影的两个元素之和是否比原值小，如果是，那就更新为新的值。迭代公式为：Ak(i,j)=min(Ak−1(i,j),Ak−1(i,k)+Ak−1(k,j))A_k(i,j)=min(A_{k−1}(i,j), A_{k−1}(i,k)+A_{k−1}(k,j))Ak(i,j)=min(Ak−1(i,j),Ak−1(i,k)+Ak−1(k,j))
- 经历n轮后，最后得到的就是最终的最短距离了。

我们从第一轮开始，第一轮是基于原有的邻接矩阵来进行处理的：

![image-20220904102258851](https://image.itbaima.cn/markdown/2022/09/04/czu5FEq8gGsRC97.png)

此时我们看到，除了对角线以外，就是B->C和C->B的这两个位置，我们按照上面的规则，进行计算：

![image-20220904102738649](https://image.itbaima.cn/markdown/2022/09/04/i3csRCQaxW17jV9.png)

同样的，我们继续看到C->B这个为止，按照同样的方式进行更新：

![image-20220904103010762](https://image.itbaima.cn/markdown/2022/09/04/TsIgShcqrdR3BaQ.png)

最后更新完成得到的结果如下：

![image-20220904103033008](https://image.itbaima.cn/markdown/2022/09/04/dObC8f2u6SqX4eT.png)

实际上我们发现，我们计算的和相当于是绕路的结果与当前直接走的结果相比较得到的。按照的同样的方式，我们开始第二轮：

![image-20220904103410691](https://image.itbaima.cn/markdown/2022/09/04/tXkEVLqR5dIchWT.png)

更新完成之后，C->A的距离变成了5：

![image-20220904103549079](https://image.itbaima.cn/markdown/2022/09/04/b9SGVFR6xEWBtgp.png)

我们接着来看最后一轮：

![image-20220904103724239](https://image.itbaima.cn/markdown/2022/09/04/alRYcGDp8xETLn1.png)

此时我们将A->B的距离也更新一下：

![image-20220904103815369](https://image.itbaima.cn/markdown/2022/09/04/Qwa2JMLXYBhnFsd.png)

最后我们得到的矩阵，存放的就是所有顶点之间的最短距离了，当然这里我们只计算了最短距离，没有去记录从哪个方向到达此顶点的，各位小伙伴也可以在计算的同时单独在另一个表中记录一下从哪个顶点过去计算出来的最小距离，这里就不演示了。实际上这个算法对我们来说是更好理解的一种算法，并且在编写程序时也会很简单，我们以下图为例：

![image-20220904105442929](https://image.itbaima.cn/markdown/2022/09/04/9fuBUwRYav4bghd.png)

代码如下：

```c
#define INF 210000000
#define N 4

int min(int a, int b){
    return a > b ? b : a;
}

void floyd(int matrix[N][N], int n){
    for (int k = 0; k < n; ++k)    //一共需要执行K轮
        for (int i = 0; i < n; ++i)   //i和j从0开始就行了，直接全看，不会影响结果的
            for (int j = 0; j < n; ++j)
                matrix[i][j] = min(matrix[i][k] + matrix[k][j], matrix[i][j]);   //按照规则更新就行了
}

int main(){
    int matrix[N][N] = {{0, 1, INF, INF},
                        {4, 0, INF, 5},
                        {INF, 2, 0, INF},
                        {3, INF, 7, 0}};

    floyd(matrix, N);

    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j)
            printf("%d ", matrix[i][j]);
        putchar('\n');
    }
}
```

最后得到的结果为：

![image-20220904110149836](https://image.itbaima.cn/markdown/2022/09/04/mDWY8ZzqSipRGFa.png)

经过对比，确实是最短的路径了。

### 拓扑排序

我们接着来看**拓扑排序**，实际上我们生活中可能会遇到下面的问题：

比如我们的大学课程的学习，一些课程开启可能需要修完一些前置课程，比如数据结构开课需要先修完C语言程序设计，Java开课需要修完计算机网络、计算机组成原理等课程，我们在到达某个阶段之前，需要完成一些前置条件才可以解锁。包括我们游戏中的任务，需要先完成哪些主线任务，完成哪些支线任务，才能解锁新的阶段。

我们可以将这些任务都看做是一个顶点，最后就能够连接成一个有向图：

![image-20220904110937920](https://image.itbaima.cn/markdown/2022/09/04/OoPBQgd9WrSJhNx.png)

因为始终是由前置条件来解锁后续，所以说整个图中是不可以出现循环的（要是有循环的话就没办法继续了，就像先有鸡还是先有蛋的问题一样）所以说构建出来的这种图我们也称为**有向无环图**（DAG），其实按照我们通俗的话来说，它就是个流程图罢了，我们只需要按照这个流程图来进行即可。像这种顶点表示活动或任务的图也称为**AOV图**。

**拓扑排序**（Topological Order）是指，将一个有向无环图（Directed Acyclic Graph）进行排序进而得到一个有序的线性序列。

比如上图的拓扑排序可以是以下的几种：

- A,B,C,D,E,F,G,H,I,J
- A,C,D,B,E,F,G,H,I,J
- A,D,C,B,E,F,G,H,I,J
- A,B,D,C,E,F,G,H,I,J

只要我们保证前置任务在后续任务之前完成即可，前置任务的完成顺序不做要求，所以拓扑排序不唯一。

![image-20220904121459739](https://image.itbaima.cn/markdown/2022/09/04/uMWBeLlzh9vHpdC.png)

那么我们在程序中如何对一个有向无环图进行拓扑排序呢？以上图为例，其实很简单，我们还是利用队列来完成，我们每次只需要将那些入度为0的顶点，丢进队列中（注意丢进去之后记得更新一下图中其他顶点的入度）首先从A：

![image-20220904122602140](https://image.itbaima.cn/markdown/2022/09/04/7bRdsEGLMqokZCf.png)

此时队列中有A这个顶点，接着我们来看看图中剩余的顶点，哪些又是入度为0的顶点，可以看到D也是：

![image-20220904122621668](https://image.itbaima.cn/markdown/2022/09/04/quj1yedrT69OQz3.png)

当目前所有度数为0的顶点进入队列之后，我们开始出队，正式开始拓扑排序，在出队时直接打印，并且查看，当此顶点离开图之后，图中会不会有其他顶点的入度变为0，如果有，将其他顶点入队。比如此时A出队之后，那么A要从图中移除，现在B也变成了入度为0的顶点，所以说将B丢进队列：

![image-20220904122914376](https://image.itbaima.cn/markdown/2022/09/04/23gdNArusypQS84.png)

接着，我们继续让D出队，我们发现D出队之后，E变成了入度为0的顶点，所以说将E入队：

![image-20220904123206951](https://image.itbaima.cn/markdown/2022/09/04/wjZ4TFslOL69IBA.png)

接着我们继续出队，B出队之后，我们发现没有任何顶点入度变为0了，所以说不管，继续：

![image-20220904123257858](https://image.itbaima.cn/markdown/2022/09/04/gWDMYimuxjFN45O.png)

继续将E出队，在E出队之后，顶点F、C都变成了入度为0的顶点，统统入队：

![image-20220904123445483](https://image.itbaima.cn/markdown/2022/09/04/uiXtEYK5aIWxNl4.png)

此时继续将C出队，我们发现没有任何顶点入队变为0，我们继续来看F：

![image-20220904123544940](https://image.itbaima.cn/markdown/2022/09/04/ue1dkjGcLKg3TCY.png)

当F出队后，顶点G变成了入度为0的顶点，此时将G入队：

![image-20220904123635522](https://image.itbaima.cn/markdown/2022/09/04/yqDC2BFQpElfz1L.png)

剩下就是把G出队，然后F入队F再出队了：

![image-20220904123742305](https://image.itbaima.cn/markdown/2022/09/04/2Na4UxFBJV6u3eR.png)

最后得到的拓扑序列为：ADBECFGH，其实思路还是比较简单的，当然，其实我们利用拓扑排序算法可以检测一个有向图是否为有向无环图，也就是说顶点还没遍历完队列就空了的话，说明一定出现了回路。

### 关键路径计算

经过前面的学习，我们知道一个任务可能会存在前置任务，只不过我们仅仅是简单讨论了任务的完成顺序，如果此时我们为每个任务添加一个权重，表示任务所需要花费的时间，那么我们的后续任务就需要前置任务全部按时间完成之后才能继续：

![image-20220904130014247](https://image.itbaima.cn/markdown/2022/09/04/uUPRtKrGBbXlNHi.png)

比如A代表某个任务（事件），B代表另一个任务，我们需要先花费2天时间完成A之后，才能开始B，活动包括时间用边来表示，我们将边作为活动的图称为**AOE图**，每个事件对应着多个活动（多条边）它就像一个大工程一样，从A开始，中间需要经过各种各样的步骤，最后到H完工作为结束。

而我们需要计算的是那些最拖延工期的活动，比如要开始任务C，那么需要完成A、B才可以，完成A需要7天，完成B需要5天，由于C需要同时完成A和B才能继续，所以说A就变成了最拖延工期的任务，因为它的时间比B还长，B都完工了，还需要等待A完成才可以。只要计算出这些最拖延工期的任务，得到一条**关键路径**，我们就可以得到完成整个工程最早的时间以及各项任务可以在什么时候开工了。

我们来看看如何进行计算，我们以下图为例：

![image-20220904132328013](https://image.itbaima.cn/markdown/2022/09/04/E8UqCQoylmLMuZA.png)

我们需要计算两个东西，一个是**事件最早完成时间**（也就是要完成这个事件最快要多久），还有一个是**事件最晚开始时间**（就是这个事件在不影响工期的情况下最晚可以多久开始）：

![image-20220904132930050](https://image.itbaima.cn/markdown/2022/09/04/GeXishvJ5wmKUHW.png)

我们依然是按照之前的拓扑排序的顺序进行，首先一开始是A，因为只有一个起点A肯定是可以直接开始的，所以说最早和最晚时间都是0（注意如果出现多个起点的话，最晚开始时间就不一定了），我们接着AOE图的工作顺序，来计算任务B和C的最早和最晚时间：

![image-20220904133246766](https://image.itbaima.cn/markdown/2022/09/04/YFJonUm1x6H5AOl.png)

接着就是D和E，首先D需要B和C同时完工之后才能继续，那么也就是说需要选择B和C过来时间最长的那一个：

![image-20220904133658962](https://image.itbaima.cn/markdown/2022/09/04/qo1ZwWgSji45uv3.png)

最后就是F，到达F一共有三条路径，我们依然是选择最长的那一条，从D过来总共需要8天时间：

![image-20220904133802361](https://image.itbaima.cn/markdown/2022/09/04/M4UzkX9ePgtSV2c.png)

故整个工程的最早完成时间为8天，我们接着来看活动的最晚开始时间，现在我们要从终点倒着往回看：

![image-20220904134114068](https://image.itbaima.cn/markdown/2022/09/04/EsHI4DSYjWAVfvB.png)

首先终点一定是8，因为工期最快是在8天结束的，我们继续倒着往回走，先来看E，E需要6天才能到达，但是只需要1天就可以结束，所以 8 - 1 = 7，最晚可以在第7天时动工：

![image-20220904134310369](https://image.itbaima.cn/markdown/2022/09/04/8W2mo5D1vFN9ur6.png)

然后是D，因为D到F需要2天时间，而D已经是第6天了，总时间8天，所以说D刻不容缓，第6天就需要马上开工：

![image-20220904134445037](https://image.itbaima.cn/markdown/2022/09/04/mTkRZXpP8necDyf.png)

然后是C，C比较复杂，因为C有两个活动，一个是指向D的，一个是指向F的，我们需要单独计算每一个活动：

- C -> F：用F的最晚开始时间减去任务时间 = 8 - 3 = 5，此时C最晚可以从第5天开始。
- C -> D：用D的最晚开始时间减去任务时间 = 6 - 4 = 2，此时因为C的最早开始时间就是2，所以说C不能晚点开始。

综上，C不能晚点开始，只能从第2天就开始，因为要满足D的条件：

![image-20220904135059487](https://image.itbaima.cn/markdown/2022/09/04/7YbvfGVhlwO1yJR.png)

最后是B，B也是有两个任务，一个是指向E一个是指向D：

- B -> E：用E的最晚开始时间减去任务时间 = 7 - 3 = 4，此时B最晚可以第4天开工。
- B -> D：用D的最晚开始时间减去任务时间 = 6 - 2 = 4，同上。

所以，B的最晚开始时间可以是第4天：

![image-20220904135338214](https://image.itbaima.cn/markdown/2022/09/04/oyInZ68SxJqYm5R.png)

当然最后我们也可以计算一下A -> B和A -> C，但是由于只有这一个起点，所以说算出来肯定是0，当然如果出现多个起点的情况，还需要进行计算得到的。

计算完成之后，我们就可以得到关键路径了，也就是那些最早和最晚时间都一样的顶点（说明是刻不容缓的，时间很紧）这些顶点连成的路线，就是我们要找的关键路径了：A -> C -> D -> F，这条路径被安排的满满当当。关键路径上的所有活动都是**关键活动**，整个工期就是由这些活动在决定的，因此，我们可通过适当加快关键活动来缩短整个项目的工期，但是注意不能加快得太猛，因为如果用力过猛可能会导致关键路径发生变化。当然，关键路径并不是唯一的，可能会出现一样的情况。

至此，有关图结构相关的内容，我们就讲解到这里。

