## 进阶排序

前面我们介绍了三种基础排序算法，它们的平均情况时间复杂度都到达了 O(n2)O(n^2)O(n2)，那么能否找到更快的排序算法呢？这一部分，我们将继续介绍前面三种排序算法的进阶版本。

### 快速排序

在C语言程序设计篇，我们也介绍过快速排序，**快速排序**是冒泡排序的进阶版本，在冒泡排序中，进行元素的比较和交换是在相邻元素之间进行的，元素每次交换只能移动一个位置，所以比较次数和移动次数较多，效率相对较低。而在快速排序中，元素的比较和交换是从两端向中间进行的，较大的元素一轮就能够交换到后面的位置，而较小的元素一轮就能交换到前面的位置，元素每次移动的距离较远，所以比较次数和移动次数较少，就像它的名字一样，速度更快。

实际上快速排序每一轮的目的就是将大的丢到基准右边去，小的丢到基准左边去。

设数组长度为N，详细过程为：

- 在一开始，排序范围是整个数组
- 排序之前，我们选择整个排序范围内的第一个元素作为基准，对排序范围内的元素进行快速排序
- 先从最右边向左看，依次将每一个元素与基准元素进行比较，如果发现比基准元素小，那么就与左边遍历位置上的元素（一开始是基准元素的位置）进行交换，此时保留右边当前遍历的位置。
- 交换后，转为从左往右开始遍历元素，如果发现比基准元素大，那么就与之前保留的右边遍历的位置上的元素进行交换，同样保留左边当前的位置，循环执行上一个步骤。
- 当左右遍历撞到一起时，本轮快速排序完成，最后在最中间的位置就是基准元素的位置了。
- 以基准位置为中心，划分左右两边，以同样的方式执行快速排序。

比如下面的数组：

![image-20220904212453328](https://image.itbaima.cn/markdown/2022/09/04/BYOvgd3XCspNI9i.png)

首先我们选择第一个元素4作为基准元素，一开始左右指针位于两端：

![image-20220905210056432](https://image.itbaima.cn/markdown/2022/09/05/LneNjifuZ4JOgKl.png)

此时从右往左开始看，直到遇到一个比4小的元素，首先是6，肯定不是，将指针往后移动：

![image-20220905210625181](https://image.itbaima.cn/markdown/2022/09/05/zVkd4wvAq9FK2ET.png)

此时继续让3和4进行比较，发现比4小，那么此时直接将3交换（其实直接覆盖过去就行了）到左边指针所指向的元素位置：

![image-20220905210730105](https://image.itbaima.cn/markdown/2022/09/05/Z7y3sO5qDWxYdiL.png)

此时我们转为从左往右看，如果遇到比4大的元素，就交换到右边指针处，3肯定不是了，因为刚刚才缓过来，接着就是2：

![image-20220905210851474](https://image.itbaima.cn/markdown/2022/09/05/cXk7xEp2IfSH9iq.png)

2也没有4大，所以说继续往后看，此时7比4要大，那么继续交换：

![image-20220905211300102](https://image.itbaima.cn/markdown/2022/09/05/zn8asNlCbOyv1cA.png)

接着，又开始从右往左看：

![image-20220905211344027](https://image.itbaima.cn/markdown/2022/09/05/APvaMt4jJV79Dpn.png)

此时5是比4要大的，继续向前，发现1比4要小，所以说继续交换：

![image-20220905211427939](https://image.itbaima.cn/markdown/2022/09/05/cCi1xkSfIVjEsPK.png)

接着又转为从左往右看，此时两个指针撞到一起了，排序结束，最后两个指针所指向的位置就是给基准元素的位置了：

![image-20220905211543845](https://image.itbaima.cn/markdown/2022/09/05/eaRN5ZvVs8bc9lU.png)

本轮快速排序结束后，左边不一定都是有序的，但是一定比基准元素要小，右边一定比基准元素大。接着我们以基准为中心，分成两个部分再次进行快速排序：

![image-20220905211741787](https://image.itbaima.cn/markdown/2022/09/05/4MLoPCKs1W9Y3Ox.png)

这样，我们最后就可以使得整个数组有序了，当然快速排序还有其他的说法，有些是左右都找到了再交换，我们这里的是只要找到就丢过去。既然现在思路已经清楚了，我们就来尝试实现一下快速排序吧：

```c
void quickSort(int arr[], int start, int end){
    if(start >= end) return;    //范围不可能无限制的划分下去，要是范围划得都没了，肯定要结束了
    int left = start, right = end, pivot = arr[left];   //这里我们定义两个指向左右两个端点的指针，以及取出基准
    while (left < right) {     //只要两个指针没相遇，就一直循环进行下面的操作
        while (left < right && arr[right] >= pivot) right--;   //从右向左看，直到遇到比基准小的
        arr[left] = arr[right];    //遇到比基准小的，就丢到左边去
        while (left < right && arr[left] <= pivot) left++;   //从左往右看，直到遇到比基准大的
        arr[right] = arr[left];    //遇到比基准大的，就丢到右边去
    }
    arr[left] = pivot;    //最后相遇的位置就是基准存放的位置了
    quickSort(arr, start, left - 1);   //不包含基准，划分左右两边，再次进行快速排序
    quickSort(arr, left + 1, end);
}
```

这样，我们就实现了快速排序。我们还是来分析一下快速排序的稳定性，快速排序是只要遇到比基准小或者大的元素就直接交换，比如原数组就是：**2**,2,1，此时第一个元素作为基准，首先右边1会被丢过来，变成：1,2,1，然后从左往右，因为只有遇到比基准2更大的元素才会换，所以说最后基准会被放到最后一个位置：1,2,**2**，此时原本应该在前面的2就跑到后面去了，所以说快速排序算法，是一种**不稳定的**排序算法。

**双轴快速排序（选学）**

这里需要额外补充个快速排序的升级版，**双轴快速排序**，Java语言中的数组工具类则是采用的此排序方式对大数组进行排序的。我们来看看它相比快速排序，又做了哪些改进。首先普通的快速排序算法在遇到极端情况时可能会这样：

![image-20220906131959909](https://image.itbaima.cn/markdown/2022/09/06/aEbUInwHOTi1GF7.png)

整个数组正好是倒序的，那么相当于上来就要把整个数组找完，然后把8放到最后一个位置，此时第一轮结束：

![image-20220906132112592](https://image.itbaima.cn/markdown/2022/09/06/erMHzcW58vVqFGa.png)

由于8直接跑到最右边了，那么此时没有右半部分，只有做半部分，此时左半部分继续进行快速排序：

![image-20220906132244369](https://image.itbaima.cn/markdown/2022/09/06/6yQa7e8VTYgpUZN.png)

此时1又是最小的一个元素，导致最后遍历完了，1都还是在那个位置，此时没有左半部分，只有右半部分：

![image-20220906132344525](https://image.itbaima.cn/markdown/2022/09/06/r9LlRfEotZMmdDn.png)

此时基准是7，又是最大的，真是太倒霉了，排完之后7跑到最左边，还是没有右半部分：

![image-20220906132437765](https://image.itbaima.cn/markdown/2022/09/06/PicWXjIBMnfUd7H.png)

我们发现，在这种极端情况下，每一轮需要完整遍历整个范围，并且每一轮都会有一个最大或是最小的元素被推向两边，这不就是冒泡排序吗？所以说，在极端情况下，快速排序会退化为冒泡排序，因此有些快速排序会随机选取基准元素。为了解决这种在极端情况下出现的问题，我们可以再添加一个基准元素，这样即使出现极端情况，除非两边都是最小元素或是最大元素，否则至少一个基准能正常进行分段，出现极端情况的概率也会减小很多：

![image-20220906132945691](https://image.itbaima.cn/markdown/2022/09/06/2YBc1goqMGwuTs4.png)

此时第一个元素和最后一个元素都作为基准元素，将整个返回划分为三段，假设基准1小于基准2，那么第一段存放的元素全部要小于基准1，第二段存放的元素全部要不小于基准1同时不大于基准2，第三段存放的元素全部要大于基准2：

![image-20220906133219853](https://image.itbaima.cn/markdown/2022/09/06/MsvJC1OtnbuGye9.png)

因此，在划分为三段之后，每轮双轴快排结束后需要对这三段分别继续进行双轴快速排序，最后就可以使得整个数组有序了，当然这种排序算法更适用于哪些量比较大的数组，如果量比较小的话，考虑到双轴快排要执行这么多操作，其实还不如插入排序来的快。

我们来模拟一下双轴快速排序是如何进行的:

![image-20220906140255444](https://image.itbaima.cn/markdown/2022/09/06/WFASGVCJaQHhBX3.png)

首先取出首元素和尾元素作为两个基准，然后我们需要对其进行比较，如果基准1大于基准2，那么需要先交换两个基准，只不过这里因为4小于6，所以说不需要进行交换。

此时我们需要创建三个指针：

![image-20220906140538076](https://image.itbaima.cn/markdown/2022/09/06/y283Ne7M6XmUtZA.png)

因为有三个区域，其中蓝色指针位置及其左边的区域都是小于基准1的，橙色指针左边到蓝色指针之间的区域都是不小于基准1且不大于基准2的，绿色指针位置及其右边的区域都是大于基准2的，橙色指针和绿色指针之间的区域，都是待排序区域。

首先我们从橙色指针所指元素开始进行判断，分三种情况：

- 如果小于基准1，那么需要先将蓝色指针向后移，把元素交换换到蓝色指针那边去，然后橙色指针也向后移动。
- 如果不小于基准1且不大于基准2，那么不需要做什么，直接把橙色指针向前移动即可，因为本身就是这个范围。
- 如果大于基准2，那么需要丢到右边去，先将右边指针左移，不断向前找到一个不比基准2大的，这样才能顺利地交换过去。

首先我们来看看，此时橙色指针指向的是2，那么2是小于基准1的，我们需要先将蓝色指针后移，然后交换橙色和蓝色指针上的元素，只不过这里由于是同一个，所以说不变，此时两个指针都后移了一位：

![image-20220906141556398](https://image.itbaima.cn/markdown/2022/09/06/HA8tKzv6Uri45p1.png)

同样的，我们继续来看橙色指针所指元素，此时为7，大于基准2，那么此时需要在右边找到一个不大于基准2的元素：

![image-20220906141653453](https://image.itbaima.cn/markdown/2022/09/06/Nj2PvlyYCnSb3kV.png)

绿色指针从右开始向左找，此时找到3，直接交换橙色指针和蓝色指针元素：

![image-20220906141758610](https://image.itbaima.cn/markdown/2022/09/06/J3ymMprRPTSHFWi.png)

下一轮开始继续看橙色指针元素，此时发现是小于基准1的，所以说先向前移动蓝色指针，发现和橙色又在一起了，交换了跟没交换一样，此时两个指针都后移了一位：

![image-20220906141926006](https://image.itbaima.cn/markdown/2022/09/06/7iSnb8ctryz6A1l.png)

新的一轮继续来看橙色指针所指元素，此时我们发现1也是小于基准1的，先移动蓝色指针，再交换，在移动橙色指针，跟上面一样，交换个寂寞：

![image-20220906142041202](https://image.itbaima.cn/markdown/2022/09/06/wrgQAsSTHjd5Ynq.png)

此时橙色指针指向8，大于基准2，那么同样需要在右边继续找一个不大于基准2的进行交换：

![image-20220906142134949](https://image.itbaima.cn/markdown/2022/09/06/udGnpJHzxP8SK4l.png)

此时找到5，满足条件，交换即可：

![image-20220906142205055](https://image.itbaima.cn/markdown/2022/09/06/oEycNqQVhbuC3Tx.png)

我们继续来看橙色指针，发现此时橙色指针元素不小于基准1且不大于基准2，那么根据前面的规则，只需要向前移动橙色指针即可：

![image-20220906142303329](https://image.itbaima.cn/markdown/2022/09/06/YSxmL2tiyBQGl8C.png)

此时橙色指针和绿色指针撞一起了，没有剩余待排序元素了，最后我们将两个位于两端点基准元素与对应的指针进行交换，基准1与蓝色指针交换，基准2与绿色指针进行交换：

![image-20220906142445417](https://image.itbaima.cn/markdown/2022/09/06/C2AnBDiUp7qxuSb.png)

此时分出来的三个区域，正好满足条件，当然这里运气好，直接整个数组就有序了，不过按照正常的路线，我们还得继续对这剩下的三个区域进行双轴快速排序，最后即可排序完成。

现在我们来尝试编写一下双轴快速排序的代码：

```c
void dualPivotQuickSort(int arr[], int start, int end) {
    if(start >= end) return;     //首先结束条件还是跟之前快速排序一样，因为不可能无限制地分下去，分到只剩一个或零个元素时该停止了
    if(arr[start] > arr[end])    //先把首尾两个基准进行比较，看看谁更大
        swap(&arr[start], &arr[end]);    //把大的换到后面去
    int pivot1 = arr[start], pivot2 = arr[end];    //取出两个基准元素
    int left = start, right = end, mid = left + 1;   //因为分了三块区域，此时需要三个指针来存放
    while (mid < right) {    //因为左边冲在最前面的是mid指针，所以说跟之前一样，只要小于right说明mid到right之间还有没排序的元素
        if(arr[mid] < pivot1)     //如果mid所指向的元素小于基准1，说明需要放到最左边
            swap(&arr[++left], &arr[mid++]);   //直接跟最左边交换，然后left和mid都向前移动
        else if (arr[mid] <= pivot2) {    //在如果不小于基准1但是小于基准2，说明在中间
            mid++;   //因为mid本身就是在中间的，所以说只需要向前缩小范围就行
        } else {    //最后就是在右边的情况了
            while (arr[--right] > pivot2 && right > mid);  //此时我们需要找一个右边的位置来存放需要换过来的元素，注意先移动右边指针
            if(mid >= right) break;   //要是把剩余元素找完了都还没找到一个比基准2小的，那么就直接结束，本轮排序已经完成了
            swap(&arr[mid], &arr[right]);   //如果还有剩余元素，说明找到了，直接交换right指针和mid指针所指元素
        }
    }
    swap(&arr[start], &arr[left]);    //最后基准1跟left交换位置，正好左边的全部比基准1小
    swap(&arr[end], &arr[right]);     //最后基准2跟right交换位置，正好右边的全部比基准2大
    dualPivotQuickSort(arr, start, left - 1);    //继续对三个区域再次进行双轴快速排序
    dualPivotQuickSort(arr, left + 1, right - 1);
    dualPivotQuickSort(arr, right + 1, end);
}
```

此部分仅作为选学，不强制要求。

### 希尔排序

希尔排序是直接插入排序的进阶版本（希尔排序又叫**缩小增量排序**）插入排序虽然很好理解，但是在极端情况下会出现让所有已排序元素后移的情况（比如刚好要插入的是一个特别小的元素）为了解决这种问题，希尔排序对插入排序进行改进，它会对整个数组按照步长进行分组，优先比较距离较远的元素。

这个步长是由一个增量序列来定的，这个增量序列很关键，大量研究表明，当增量序列为 `dlta[k] = 2^(t-k+1)-1（0<=k<=t<=(log2(n+1))）`时，效率很好，只不过为了简单，我们一般使用 n2\frac {n} {2}2n、n4\frac {n} {4}4n、n8\frac {n} {8}8n、...、1 这样的增量序列。

设数组长度为N，详细过程为：

- 首先求出最初的步长，n/2即可。
- 我们将整个数组按照步长进行分组，也就是两两一组（如果n为奇数的话，第一组会有三个元素）
- 我们分别在这些分组内进行插入排序。
- 排序完成后，我们将步长/2，重新分组，重复上述步骤，直到步长为1时，插入排序最后一遍结束。

这样的话，因为组内就已经调整好了一次顺序，小的元素尽可能排在前面，即使在最后一遍排序中出现遇到小元素要插入的情况，也不会有太多的元素需要后移。

我们以下面的数组为例：

![image-20220905223505975](https://image.itbaima.cn/markdown/2022/09/05/GLEjym78BWNUtCf.png)

首先数组长度为8，直接整除2，得到34，那么步长就是4了，我们按照4的步长进行分组：

![image-20220905223609936](https://image.itbaima.cn/markdown/2022/09/05/S72NcgKBzIA54om.png)

其中，4、8为第一组，2、5 为第二组，7、3为第三组，1、6为第四组，我们分别在这四组内进行插入排序，组内排序之后的结果为：

![image-20220905223659584](https://image.itbaima.cn/markdown/2022/09/05/XO4a9HKP7vhGTmf.png)

可以看到目前小的元素尽可能地在往前面走，虽然还不是有序的，接着我们缩小步长，4/2=2，此时按照这个步长划分：

![image-20220905223804907](https://image.itbaima.cn/markdown/2022/09/05/sdKhcGmapgOZkCP.png)

此时4、3、8、7为一组，2、1、5、6为一组，我们继续在这两个组内进行排序，得到：

![image-20220905224111803](https://image.itbaima.cn/markdown/2022/09/05/MD8UFxJvg274Qw6.png)

最后我们继续将步长/2，得到2/2=1，此时步长变为1，也就相当于整个数组为一组，再次进行一次插入排序，此时我们会发现，小的元素都靠到左边来了，此时再进行插入排序会非常轻松。

我们现在就来尝试编写一下代码：

```c
void shellSort(int arr[], int size){
    int delta = size / 2;
    while (delta >= 1) {
        //这里依然是使用之前的插入排序，不过此时需要考虑分组了
        for (int i = delta; i < size; ++i) {   //我们需要从delta开始，因为前delta个组的第一个元素默认是有序状态
            int j = i, tmp = arr[i];   //这里依然是把待插入的先抽出来
            while (j >= delta && arr[j - delta] > tmp) {   
              	//注意这里比较需要按步长往回走，所以说是j - delta，此时j必须大于等于delta才可以，如果j - delta小于0说明前面没有元素了
                arr[j] = arr[j - delta];
                j -= delta;
            }
            arr[j] = tmp;
        }
        delta /= 2;    //分组插排完事之后，重新计算步长
    }
}
```

虽然这里用到了三层循环嵌套，但是实际上的时间复杂度可能比 O(n2)O(n^2)O(n2) 还小，因为能够保证小的元素一定往左边靠，所以排序次数实际上并没有我们想象中的那么多，由于证明过程过于复杂，这里就不列出了。

那么希尔排序是不是稳定的呢？因为现在是按步长进行分组，有可能会导致原本相邻的两个相同元素，后者在自己的组内被换到前面去了，所以说希尔排序是**不稳定的**排序算法。

### 堆排序

我们来看最后一种，堆排序也是选择排序的一种，但是它能够比直接选择排序更快。还记得我们前面讲解的大顶堆和小顶堆吗？我们来回顾一下：

> 对于一棵完全二叉树，树中父亲结点都比孩子结点小的我们称为**小根堆**（小顶堆），树中父亲结点都比孩子结点大则是**大根堆**

得益于堆是一棵完全二叉树，我们可以很轻松地使用数组来进行表示：

![image-20220818110224673](https://image.itbaima.cn/markdown/2022/08/18/XpYVN2gslOfWLSr.png)

我们通过构建一个堆，就可以将一个无序的数组依次输入，最后存放的序列是一个按顺序排放的序列，利用这种性质，我们可以很轻松地利用堆进行排序，我们先来写一个小顶堆：

```c
typedef int E;
typedef struct MinHeap {
    E * arr;
    int size;
    int capacity;
} * Heap;

_Bool initHeap(Heap heap){
    heap->size = 0;
    heap->capacity = 10;
    heap->arr = malloc(sizeof (E) * heap->capacity);
    return heap->arr != NULL;
}

_Bool insert(Heap heap, E element){
    if(heap->size == heap->capacity) return 0;
    int index = ++heap->size;
    while (index > 1 && element < heap->arr[index / 2]) {
        heap->arr[index] = heap->arr[index / 2];
        index /= 2;
    }
    heap->arr[index] = element;
    return 1;
}

E delete(Heap heap){
    E max = heap->arr[1], e = heap->arr[heap->size--];
    int index = 1;
    while (index * 2 <= heap->size) {
        int child = index * 2;
        if(child < heap->size && heap->arr[child] > heap->arr[child + 1])
            child += 1;
        if(e <= heap->arr[child]) break;
        else heap->arr[index] = heap->arr[child];
        index = child;
    }
    heap->arr[index] = e;
    return max;
}
```

接着我们只需要将这些元素挨个插入到堆中，然后再挨个拿出来，得到的就是一个有序的顺序了：

```c
int main(){
    int arr[] = {3, 5, 7, 2, 9, 0, 6, 1, 8, 4};

    struct MinHeap heap;    //先创建堆
    initHeap(&heap);
    for (int i = 0; i < 10; ++i)
        insert(&heap, arr[i]);   //直接把乱序的数组元素挨个插入
    for (int i = 0; i < 10; ++i)
        arr[i] = delete(&heap);    //然后再一个一个拿出来，就是按顺序的了

    for (int i = 0; i < 10; ++i)
        printf("%d ", arr[i]);
}
```

最后得到的结果为：

![image-20220906001134488](https://image.itbaima.cn/markdown/2022/09/06/iedURC8vVpcMgn6.png)

虽然这样用起来比较简单，但是需要额外 O(n)O(n)O(n) 的空间来作为堆，所以我们可以对其进行进一步的优化，减少其空间上的占用。那么怎么进行优化呢，我们不妨换个思路，直接对给定的数组进行堆的构建。

设数组长度为N，详细过程为：

- 首先将给定的数组调整为一个大顶堆
- 进行N轮选择，每次都选择大顶堆顶端的元素从数组末尾开始向前存放（交换堆顶和堆的最后一个元素）
- 交换完成后，重新对堆的根结点进行调整，使其继续满足大顶堆的性质，然后重复上述操作。
- 当N轮结束后，得到的就是从小到大排列的数组了。

我们先将给定数组变成一棵完全二叉树，以下面数组为例：

![image-20220906220020172](https://image.itbaima.cn/markdown/2022/09/06/GTkWlzpZbxMX58K.png)

此时，这棵二叉树还并不是堆，我们的首要目标是将其变成一个大顶堆。那么怎么将这棵二叉树变成一个大顶堆呢？我们只需要从最后一个非叶子结点（从上往下的顺序）开始进行调整即可，比如此时1是最后一个非叶子结点，所以说就从1开始，我们需要进行比较，如果其孩子结点大于它，那么需要将最大的那个孩子交换上来，此时其孩子结点6大于1，所以说需要交换：

![image-20220906221306519](https://image.itbaima.cn/markdown/2022/09/06/bpnSDlOLKawGRxT.png)

接着我们来看倒数第二个非叶子结点，也就是7，那么此时两个孩子都是小于它的，所以说不需要做任何调整，我们接着来看倒数第三个非叶子结点2，此时2的两个孩子6、8都大于2，那么我们选择两个孩子里面一个最大的交换上去：

![image-20220906221504364](https://image.itbaima.cn/markdown/2022/09/06/svNPURhJbzAQo9d.png)

最后就剩下根结点这一个非叶子结点了，此时我们4的左右孩子都大于4，那么依然需要进行调整：

![image-20220906221657599](/Users/nagocoler/Library/Application Support/typora-user-images/image-20220906221657599.png)

在调整之后，还没有结束，因为此时4换下去之后依然不满足大顶堆的性质，此时4的左孩子大于4，我们还需要继续向下看：

![image-20220906221833012](https://image.itbaima.cn/markdown/2022/09/06/MmzbFTLYSZAW4gv.png)

交换之后，此时整个二叉树就满足大顶堆的性质了，我们第一次初始调整也就完成了。

此时开始第二步，我们需要一个一个地将堆顶元素往后面进行交换，相当于每次都去取一个最大的出来，直到取完，首先交换堆顶元素和最后一个元素：

![image-20220906222327297](https://image.itbaima.cn/markdown/2022/09/06/8fBeubxnqD1rJEZ.png)

此时整个数组中最大的元素已经排到对应的位置上了，然后我们不再考虑最后一个元素，此时将前面的剩余元素继续看做一棵完全二叉树，对根结点重新进行一次堆化（只需要调整根结点即可，因为其他非叶子结点的没有变动），使得其继续满足大顶堆的性质：

![image-20220906222819554](https://image.itbaima.cn/markdown/2022/09/06/2RTG76ejsKyCthU.png)

还没完，继续调整：

![image-20220906222858752](https://image.itbaima.cn/markdown/2022/09/06/clEdF5YBO7iKDP6.png)

此时第一轮结束，接着第二轮，重复上述操作，首先依然是将堆顶元素丢到倒数第二个位置上，相当于将倒数第二大的元素放到对应的位置上去：

![image-20220906222934602](https://image.itbaima.cn/markdown/2022/09/06/KaZGOsWD2chNf3i.png)

此时已经有两个元素排好序了，同样的，我们继续将剩余元素看做一个完全二叉树，继续对根结点进行堆化操作，使得其继续满足大顶堆性质：

![image-20220906223110734](https://image.itbaima.cn/markdown/2022/09/06/PD7FBrlqc1R8LWE.png)

第三轮同样的思路，将最大的交换到后面去：

![image-20220906223326135](https://image.itbaima.cn/markdown/2022/09/06/tKhYbOqv6Ezmc8R.png)

通过N轮排序，最后每一个元素都可以排到对应的位置上了，根据上面的思路，我们来尝试编写一下代码：

```c
//这个函数就是对start顶点位置的子树进行堆化
void makeHeap(int* arr, int start, int end) {
    while (start * 2 + 1 <= end) {    //如果有子树，就一直往下，因为调整之后有可能子树又不满足性质了
        int child = start * 2 + 1;    //因为下标是从0开始，所以左孩子下标就是i * 2 + 1，右孩子下标就是i * 2 + 2
        if(child + 1 <= end && arr[child] < arr[child + 1])   //如果存在右孩子且右孩子比左孩子大
            child++;    //那就直接看右孩子
        if(arr[child] > arr[start])   //如果上面选出来的孩子，比父结点大，那么就需要交换，大的换上去，小的换下来
            swap(&arr[child], &arr[start]);
        start = child;   //继续按照同样的方式前往孩子结点进行调整
    }
}

void heapSort(int arr[], int size) {
    for(int i= size/2 - 1; i >= 0; i--)   //我们首选需要对所有非叶子结点进行一次堆化操作，需要从最后一个到第一个，这里size/2计算的位置刚好是最后一个非叶子结点
        makeHeap(arr, i, size - 1);
    for (int i = size - 1; i > 0; i--) {   //接着我们需要一个一个把堆顶元素搬到后面，有序排列
        swap(&arr[i], &arr[0]);    //搬运实际上就是直接跟倒数第i个元素交换，这样，每次都能从堆顶取一个最大的过来
        makeHeap(arr, 0, i - 1);   //每次搬运完成后，因为堆底元素被换到堆顶了，所以需要再次对根结点重新进行堆化
    }
}
```

最后我们来分析一下堆排序的稳定性，实际上堆排序本身也是在进行选择，每次都会选择堆顶元素放到后面，只不过堆是一直在动态维护的。实际上从堆顶取出元素时，都会与下面的叶子进行交换，有可能会出现：

![image-20220906223706019](https://image.itbaima.cn/markdown/2022/09/06/oVT4rvRsKnHyqQl.png)

所以说堆排序是**不稳定的**排序算法。

最后我们还是来总结一下上面的三种排序算法的相关性质：

| 排序算法 |         最好情况         |         最坏情况         |      空间复杂度       | 稳定性 |
| :------: | :----------------------: | :----------------------: | :-------------------: | :----: |
| 快速排序 | O(nlogn)O(nlogn)O(nlogn) |     O(n2)O(n^2)O(n2)     | O(logn)O(logn)O(logn) | 不稳定 |
| 希尔排序 | O(n1.3)O(n^{1.3})O(n1.3) |     O(n2)O(n^2)O(n2)     |     O(1)O(1)O(1)      | 不稳定 |
|  堆排序  | O(nlogn)O(nlogn)O(nlogn) | O(nlogn)O(nlogn)O(nlogn) |     O(1)O(1)O(1)      | 不稳定 |

